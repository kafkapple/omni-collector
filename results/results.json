[
    {
        "title": "SuperClaude: Claude Code를 위한 개발 프레임워크",
        "url": "https://discuss.pytorch.kr/t/superclaude-claude-code/7188",
        "source": "pytorch_kr",
        "body": "SuperClaude: Claude Code를 위한 개발 프레임워크882×202 20.2 KBSuperClaude 소개AI 기반 개발 도구가 점점 더 복잡하고 다양해지면서, 단순한 코드 보조 도구를 넘어 실질적인 개발 지원 체계를 갖춘 프레임워크의 수요가 커지고 있습니다. 특히 Anthropic의 Claude와 같은 고성능 LLM(Language Model)을 활용한 개발 방식이 대중화되면서, 이를 보다 체계적이고 효율적으로 활용할 수 있는 도구의 필요성이 대두되고 있습니다. 이런 배경에서 등장한 것이 바로SuperClaude입니다. 이 프로젝트는 Claude Code를 확장하고 구조화하여, 개발 전반을 지원하는 명령어 체계, 전문화된 인지 페르소나(Persona), 토큰 최적화 및 증거 기반 개발 방식 등을 제공합니다.기존 Claude 사용자가 겪는 한계는 주로 “어떻게” 사용해야 하는지에 대한 가이드 부재, 명확한 개발 흐름의 부재, 그리고 다양한 기술 도메인에서의 전문성 부족이었습니다. SuperClaude는 이를 해결하기 위해 다양한 페르소나를 통해 역할 기반 접근 방식을 도입하고, 명령어 중심의 워크플로우를 구성하며, 개발 맥락(context)을 유지할 수 있도록 MCP 통합 등을 지원합니다.개발자가 Claude를 통해 실질적인 프로젝트 구현을 진행하려면 단순히 모델에 질문하는 수준을 넘어서, 개발, 테스트, 분석, 배포, 문서화 등의 복잡한 프로세스를 조직적으로 다룰 수 있어야 합니다. SuperClaude는 이 전 과정을 아우를 수 있는 통합적인 프레임워크로서 기능하며, 개발 팀 단위의 효율성과 일관성을 제공하고자 합니다.SuperClaude는 기본적인 Claude Code 사용 방식에 비해 다음과 같은 차별성을 가집니다:항목공식 Claude CodeSuperClaude전문성일반적인 질문 응답도메인별 인지 페르소나명령 체계수동적 사용18개 워크플로우 명령어컨텍스트세션 기반Git 체크포인트, MCP토큰 사용비최적화압축 및 캐시 기반 최적화개발 방식일반 목적증거 기반, 문서화 중심도구 통합없음 또는 기본MCP(브라우저 자동화 등) 통합SuperClaude의 핵심 구성 요소인지 페르소나 시스템SuperClaude는 총 9개의 도메인별 인지 페르소나를 통해 사용자가 AI와 상호작용할 때 적합한 사고방식을 선택할 수 있도록 합니다. 예를 들어/analyze --code --persona-architect명령을 사용하면 시스템 설계에 특화된 분석을 받을 수 있습니다. 이 페르소나들은 단순히 역할을 나누는 것이 아니라, AI의 접근 방식을 근본적으로 바꿔줍니다.SuperClaude가 제공하는 도메인별 페르소나들의 목록은 다음과 같습니다:PersonaFocus AreaToolsUse CasesarchitectSystem designSequential, Context7Architecture planningfrontendUser experienceMagic, Puppeteer, Context7UI developmentbackendServer systemsContext7, SequentialAPI developmentsecuritySecurity analysisSequential, Context7Security reviewsanalyzerProblem solvingAll MCP toolsDebuggingqaQuality assurancePuppeteer, Context7TestingperformanceOptimizationPuppeteer, SequentialPerformance tuningrefactorerCode qualitySequential, Context7Code improvementmentorKnowledge sharingContext7, SequentialDocumentation통합 명령어 시스템개발 생애주기를 커버하는 총 19개의 명령어가 제공됩니다. 예를 들어,/build,/test,/deploy,/review,/scan등이 있으며, 각 명령어는 다양한 플래그를 통해 세분화된 기능을 수행할 수 있습니다. /test --coverage --e2e --pup 명령은 통합 테스트와 브라우저 테스트까지 지원합니다.19개의 명령어는 소프트웨어 개발의 수명주기에 맞춰 아래와 같이 총 4개의 카테고리로 나뉘어 있습니다:Development: 개발 관련 명령어 (3개)/build: 다양한 스택 템플릿을 기반으로 프로젝트를 초기화하거나 기능을 구현할 수 있는 빌더 명령어입니다.--react,--magic,--tdd등의 플래그로 프론트엔드부터 테스트 주도 개발(TDD)까지 세부 조정이 가능합니다./dev-setup: 개발 환경을 자동으로 설정해 주는 명령어로, CI 구성, 모니터링 설정 등 반복적인 셋업 작업을 자동화합니다./test: 테스트 프레임워크 명령어로, 커버리지 분석, E2E 테스트, Puppeteer 기반의 브라우저 테스트를 조합할 수 있습니다.Analysis & Improvement: 분석 및 개선 관련 명령어 (5개)/review: Claude AI를 활용한 코드 리뷰 명령어입니다. 품질 플래그(--quality)와 증거 기반 평가(--evidence)를 결합해 명확한 피드백을 제공합니다./analyze: 시스템 구조, 성능, 코드 품질 등의 전반적인 분석을 수행합니다. 시퀀셜 추론(--seq)이나 페르소나 지정으로 깊이 있는 분석이 가능합니다./troubleshoot: 운영 환경에서 발생한 문제를 진단하고 해결하는 데 초점을 맞춘 명령어입니다.--prod,--five-whys등의 옵션으로 원인 분석에 도움을 줍니다./improve: 성능 개선, 코드 리팩토링, 품질 향상 등을 수행하는 명령어입니다. 반복 개선(--iterate)이나 성능 기준(--threshold)도 지정할 수 있습니다./explain: 복잡한 코드를 시각적으로 설명하거나 문서화하는 데 유용한 명령어입니다.--depth,--visual등의 옵션으로 설명 수준을 조절할 수 있습니다.Operations: 운영 관련 명령어 (6개)/deploy: 배포를 계획하고 실행하는 명령어로,--env(배포 환경) 및--plan옵션으로 안전하게 운영할 수 있습니다./migrate: 데이터베이스 또는 시스템 마이그레이션을 지원합니다.--dry-run,--rollback옵션으로 리스크를 줄일 수 있습니다./scan: 보안 및 종속성 검증을 자동으로 수행하는 명령어입니다. OWASP 기준 점검 및 보안 페르소나와의 연동이 가능합니다./estimate: 프로젝트 리소스, 시간, 리스크 등을 추정하는 명령어로,--detailed,--worst-case옵션 등 정밀한 계획이 가능합니다./cleanup: 시스템 정리 및 유지 관리를 수행합니다. 불필요한 파일 제거와 설정 검증을 자동화합니다./git: Git 워크플로우를 관리하는 명령어입니다. 브랜치 전략, 커밋 메시지 생성, 병합 전략 등을 자동으로 도와줍니다.Design & Workflow: 설계 및 작업 흐름 관련 명령어 (5개)/design: 시스템 아키텍처를 설계할 수 있는 명령어로, DDD, API 설계, 경계 컨텍스트 등을 정의할 수 있습니다./spawn: 병렬 작업을 실행할 수 있는 명령어로, 다수의 태스크를 동시에 실행하거나 모듈별 빌드에 활용됩니다./document: 문서 생성을 자동화합니다. 코드 기반의 문서화뿐만 아니라 설계 문서, API 명세서 작성도 지원합니다./load: 프로젝트 컨텍스트를 불러오는 명령어로, Claude가 현재 프로젝트 상황을 이해할 수 있도록 도움을 줍니다./task: 태스크 단위의 작업을 정의하고 관리할 수 있는 명령어입니다. 업무 관리, 할 일 목록, 역할 분담 등에 유용합니다.각 명령어는 인지 페르소나와 조합할 수 있어 개발자뿐만 아니라 설계자, 보안 전문가, QA 등 다양한 역할에서 효율적으로 Claude Code를 활용할 수 있도록 설계되었습니다. 실제 업무 흐름에 맞춰 명령어와 페르소나를 조합하면, 복잡한 프로젝트도 보다 체계적으로 관리할 수 있습니다.MCP 통합SuperClaude는 MCP(Modular Command Plugins) 시스템과 연동되며,--magic,--pup,--seq,--c7와 같은 플래그를 통해 다양한 고급 기능을 사용할 수 있습니다. 예를 들어 Puppeteer를 통한 브라우저 자동화 테스트, Context7을 통한 문서 참조, Sequential을 활용한 다단계 추론 등이 가능하며, 이는 실질적인 프로젝트 개발에 필요한 도구들입니다.설치 및 구조설치는 단일 스크립트(install.sh)로 가능하며, 업데이트 모드, 드라이런, 자동 백업, 플랫폼 감지 기능 등을 제공합니다. 기본적으로~/.claude/경로에 설치되며, 기존 설정과의 충돌 없이 사용할 수 있습니다.구성 방식모든 설정은 CLAUDE.md에서 중앙 관리됩니다.@include시스템을 통해 구성 요소 재사용이 가능하며, 중복을 최소화합니다.명령어, 페르소나, 설정 템플릿이 모두 모듈화되어 있어 확장성이 뛰어납니다.사용 예시UI 중심 개발/build --react --magic --watch --persona-frontend아키텍처 설계 및 구현/design --api --ddd --bounded-context --persona-architect\n/build --api --tdd --coverage --persona-backend운영 및 문제 해결/troubleshoot --prod --persona-analyzer\n/analyze --profile --perf --seq프레임워크 자체 개선/analyze --introspect\n/improve --introspect --persona-performance라이선스SuperClaude 프로젝트는MIT 라이선스로 공개 및 배포되고 있습니다. 상업적 사용에 제한이 없으며 자유로운 수정 및 배포가 가능합니다.SuperClaude 프로젝트 GitHub 저장소github.comGitHub - NomenAK/SuperClaude: A configuration framework that enhances Claude...A configuration framework that enhances Claude Code with specialized commands, cognitive personas, and development methodologies.이 글은 GPT 모델로 정리한 글을 바탕으로 한 것으로, 원문의 내용 또는 의도와 다르게 정리된 내용이 있을 수 있습니다. 관심있는 내용이시라면 원문도 함께 참고해주세요! 읽으시면서 어색하거나 잘못된 내용을 발견하시면 덧글로 알려주시기를 부탁드립니다.파이토치 한국 사용자 모임이 정리한 이 글이 유용하셨나요?회원으로 가입하시면 주요 글들을 이메일로 보내드립니다! (기본은 Weekly지만Daily로 변경도 가능합니다.)아래쪽에 좋아요를 눌러주시면 새로운 소식들을 정리하고 공유하는데 힘이 됩니다~",
        "summary": "SuperClaude는 Anthropic의 Claude Code를 향상시킨 개발 프레임워크로,  도메인별 인지 페르소나와 19개의 개발 생애주기 명령어를 제공하여 개발 전 과정을 효율적으로 지원한다.  명령어 시스템과 페르소나, MCP 통합을 통해 개발, 테스트, 배포 등의 단계를 체계화하고,  토큰 최적화 및 증거 기반 개발 방식을 통해 효율성을 높였다.  MIT 라이선스로 공개되어 자유롭게 사용 및 수정이 가능하다.\n"
    },
    {
        "title": "Google, On-Device에 최적화된 Gemma 3n 모델 정식 출시",
        "url": "https://discuss.pytorch.kr/t/google-on-device-gemma-3n/7187",
        "source": "pytorch_kr",
        "body": "Google, On-Device에 최적화된 Gemma 3n 모델 정식 출시927×352 26.1 KBGemma 3n 모델 소개2023년 구글이 공개한 첫 번째 Gemma 모델은 AI 개발자 커뮤니티와 오픈소스 생태계에서 매우 큰 반향을 일으켰습니다. Gemma는 공개 이후 1억 6천만 건 이상의 다운로드를 기록하며, 범용 모델뿐 아니라 의료, 보안, 컴퓨터 비전 등 다양한 특화 모델로 진화해 왔습니다. 그동안 전 세계 개발자와 연구자들은 Gemma를 활용해 독창적인 프로젝트를 진행해 왔으며, 이러한 움직임은 Gemma 모델이 실질적으로 현장의 요구에 부합하는 방향으로 발전하는 데 결정적인 역할을 했습니다.image3334×993 206 KB이러한 흐름을 바탕으로, 구글은 Gemma 3n의 정식 버전을 발표했습니다. Gemma 3n은 \"모바일 퍼스트\" 아키텍처를 기반으로 설계된 차세대 오픈 AI 모델로, 개발자를 위한 다양한 지원과 손쉬운 활용성을 핵심으로 내세웁니다. Hugging Face Transformers, llama.cpp, Google AI Edge, Ollama, MLX 등 다양한 오픈소스 생태계와의 호환성, 그리고 손쉬운 파인튜닝과 온디바이스 배포가 가능하다는 점이 큰 특징입니다.특히 Gemma 3n은 텍스트뿐만 아니라 이미지, 오디오, 비디오 등 멀티모달 데이터를 자연스럽게 처리할 수 있습니다. 기존에는 클라우드 기반 대규모 모델에서만 볼 수 있었던 성능을 엣지 디바이스와 모바일 환경에서도 구현할 수 있게 되었으며, 이는 AI 기술의 실제 응용 범위를 크게 넓힐 수 있다는 점에서 주목받고 있습니다.Gemma 3n은 기존의 Gemma 2, Llama, Phi, GPT-4o 등 여러 AI 오픈모델과 비교해 다음과 같은 차별점을 보입니다. 첫째, 멀티모달 입력(텍스트, 이미지, 오디오, 비디오)을 네이티브로 지원하면서도, 2GB~3GB 수준의 메모리에서 동작하는 초경량 설계가 특징입니다. 둘째, MatFormer(마트료시카 트랜스포머) 아키텍처를 도입해, 하나의 큰 모델 안에 여러 크기의 모델을 동적으로 내장할 수 있어 유연한 인퍼런스 및 최적화가 가능합니다. 셋째, Per Layer Embeddings, KV Cache Sharing 등 온디바이스 환경에 최적화된 다양한 구조적 혁신이 반영되어 있습니다. 마지막으로, 새로운 MobileNet-V5 비전 인코더와 USM 기반 오디오 인코더를 통해 엣지 디바이스에서의 멀티모달 처리 성능이 대폭 개선되었습니다.이러한 특장점으로 인해, Gemma 3n은 텍스트와 멀티모달 AI 응용 분야에서 Llama 3, GPT-4o-nano, Phi-4 등과 비교했을 때 10B 파라미터 미만 모델 중 최고의 벤치마크 점수(LMArena 1300+)를 기록하고 있습니다.Gemma 3n 주요 기술 및 아키텍처Gemma 3n의 주요 특징image1921×1081 138 KBGemma 3n은 온디바이스 AI 모델로 설계되어, 기존 클라우드 전용 AI와 달리 엣지 환경에서 실질적인 활용이 가능하도록 다양한 혁신 기술을 도입했습니다. 2B(E2B), 4B(E4B) 두 가지 모델 크기를 제공하며, 각각 2GB와 3GB 메모리만으로도 실행이 가능합니다. 특히, 효율적인 메모리 구조와 최신 아키텍처 혁신 덕분에 실제 인퍼런스 시 전통적인 2B/4B 모델과 유사한 메모리 사용량으로 동작합니다.또한, Gemma 3n은 멀티모달 모델로 설계되어 텍스트, 이미지, 오디오, 비디오 등 다양한 입력을 동시에 처리할 수 있습니다. 140개 언어의 텍스트 및 35개 언어의 멀티모달 이해를 지원하며, 수학, 코딩, 논리적 추론 등 고난도 태스크에서도 뛰어난 성능을 보입니다.MatFormer: 가변형 트랜스포머 아키텍처image1028×504 40.6 KBGemma 3n의 핵심은MatFormer(Matryoshka Transformer; 마트료시카 트랜스포머) 아키텍처에 있습니다. 이 구조는 하나의 모델 내에 여러 크기의 하위 모델을 중첩(마치 러시아의 마트료시카 인형처럼)시켜, 개발자가 필요에 따라 모델 크기와 성능을 유연하게 조절할 수 있도록 합니다. 예를 들어, 4B(E4B) 모델을 훈련할 때 동시에 2B(E2B) 서브모델도 함께 최적화됩니다. 이를 통해 개발자는 성능이 우선이면 E4B, 속도가 우선이면 E2B를 선택적으로 활용할 수 있습니다.image1280×720 37.6 KB또한, 'Mix-n-Match'라는 기법을 활용하면 레이어별 피드포워드 네트워크 차원이나 레이어 수를 조절하여, E2B와 E4B 사이의 다양한 커스텀 모델을 생성할 수 있습니다. 이는 실제 하드웨어 제약에 맞춘 모델 최적화와 메모리/성능 밸런싱에 큰 장점을 제공합니다.Per Layer Embeddings(레이어별 임베딩): 메모리 효율화image1028×504 41.3 KBPer Layer Embeddings(이하 PLE)는 모델 품질을 유지하면서도, 가속기(GPU/TPU) 메모리 사용량을 획기적으로 줄이는 기술입니다. PLE 덕분에, 실제로는 5B/8B 규모의 모델이지만, 고속 메모리에 올려야 할 파라미터는 2B(E2B), 4B(E4B) 수준에 불과합니다. 임베딩 파라미터는 CPU 등 느린 메모리에서 효율적으로 처리할 수 있어, 엣지 디바이스에서의 대용량 모델 운용이 현실적으로 가능해졌습니다.KV Cache Sharing: 긴 입력 처리 성능 향상오디오/비디오 스트림 등 긴 시퀀스 입력을 처리할 때, Gemma 3n은 KV Cache Sharing이라는 구조적 최적화로 초기 프리필(prefill) 단계를 대폭 단축했습니다. 이는 기존 대비 2배 빠른 시퀀스 처리 속도를 제공하며, 온디바이스 멀티모달 AI 애플리케이션의 반응성을 크게 향상시킵니다.오디오 이해: Universal Speech Model(USM) 기반Gemma 3n은 Google의Universal Speech Model(USM)을 기반으로 한 오디오 인코더를 탑재해, 160ms 단위로 오디오를 토큰화하고, 이를 자연스럽게 텍스트 처리에 통합합니다. 이를 통해 고품질 음성 인식(ASR)과 자동 음성 번역(AST)이 온디바이스에서 구현 가능합니다. 특히 영어-스페인어, 프랑스어, 이탈리아어, 포르투갈어 등 주요 언어 쌍 간 번역 성능이 매우 뛰어납니다.MobileNet-V5: 차세대 비전 인코더이미지와 영상 처리 성능 역시 크게 강화되었습니다. MobileNet-V5-300M 비전 인코더는 256x256, 512x512, 768x768 등 다양한 해상도를 지원하며, 60fps의 고속 비디오 분석이 가능합니다. 기존 대비 13배 이상의 속도, 46% 적은 파라미터, 4배 작은 메모리 풋프린트로도 높은 정확도를 기록하며, 엣지 디바이스의 실시간 멀티모달 태스크에 최적화되어 있습니다.Gemma 3n 활용 및 시작 방법Gemma 3n은 Hugging Face, Kaggle 등에서 바로 다운로드할 수 있으며, AI Studio, Ollama, llama.cpp, MLX, LMStudio 등 다양한 도구와 프레임워크에서 바로 실험 및 배포가 가능합니다. 또한, Google Cloud Vertex AI, NVIDIA API Catalog 등 여러 클라우드와 온프레미스 환경에 최적화되어 있어, 개발자는 원하는 방식대로 손쉽게 모델을 통합할 수 있습니다.구글은 Gemma 3n의 출시와 함께\"Gemma 3n Impact Challenge\" 해커톤도 개최 중입니다. 실제 온디바이스, 오프라인, 멀티모달 활용사례를 영상 데모와 함께 제출하면 총 15만 달러의 상금이 제공되니,관심 있는 개발자라면 참여해 보는 것도 좋겠습니다.라이선스Gemma 3n 모델의 라이선스는Gemma 모델 공식 라이선스로 공개 및 배포되고 있습니다. 상업적 활용에는 일부 제약이 있을 수 있으니, 반드시 라이선스 전문을 확인하시기 바랍니다.Gemma 3n 블로그 - 'Introducing Gemma 3n: The developer guide'developers.googleblog.comIntroducing Gemma 3n: The developer guide- Google Developers BlogLearn how to build with Gemma 3n, a mobile-first architecture, MatFormer technology, Per-Layer Embeddings, and new audio and vision encoders.Gemma 3n 모델 다운로드huggingface.coGemma 3n - a google CollectionWe’re on a journey to advance and democratize artificial intelligence through open source and open science.Gemma 3n 공식 문서Google AI for DevelopersGemma 3n model overview  |  Google AI for Developers더 읽어보기MatFormer 아키텍처 논문:[2310.07707] MatFormer: Nested Transformer for Elastic InferenceUniversal Speech Model(USM) 논문:[2303.01037] Google USM: Scaling Automatic Speech Recognition Beyond 100 LanguagesGemma 라이선스 문서:https://ai.google.dev/gemma/docs/gemma-licenseGoogle, 소비자용 GPU에서 실행 가능한 Gemma 3 QAT 모델 공개gemma.cpp: Gemma 모델의 빠른 실행을 위한 C++ 추론 엔진 (by Google)이 글은 GPT 모델로 정리한 글을 바탕으로 한 것으로, 원문의 내용 또는 의도와 다르게 정리된 내용이 있을 수 있습니다. 관심있는 내용이시라면 원문도 함께 참고해주세요! 읽으시면서 어색하거나 잘못된 내용을 발견하시면 덧글로 알려주시기를 부탁드립니다.파이토치 한국 사용자 모임이 정리한 이 글이 유용하셨나요?회원으로 가입하시면 주요 글들을 이메일로 보내드립니다! (기본은 Weekly지만Daily로 변경도 가능합니다.)아래쪽에 좋아요를 눌러주시면 새로운 소식들을 정리하고 공유하는데 힘이 됩니다~",
        "summary": "구글은 모바일 기기에 최적화된 새로운 오픈소스 AI 모델 Gemma 3n을 정식 출시했다.  Gemma 3n은 2GB~3GB의 메모리에서 작동하는 초경량 모델로, 텍스트뿐 아니라 이미지, 오디오, 비디오 등 멀티모달 데이터 처리가 가능하며, 다양한 오픈소스 생태계와 호환된다.  특히 MatFormer 아키텍처와 다양한 최적화 기술을 통해 엣지 디바이스에서도 높은 성능을 제공하며,  Hugging Face 등을 통해 쉽게 다운로드 및 활용이 가능하다.\n"
    },
    {
        "title": "ZINK (Zero-shot INK): 민감정보 비식별화를 위한 제로샷 텍스트 처리 도구",
        "url": "https://discuss.pytorch.kr/t/zink-zero-shot-ink/7196",
        "source": "pytorch_kr",
        "body": "ZINK (Zero-shot INK): 민감정보 비식별화를 위한 제로샷 텍스트 처리 도구1548×420 45.7 KBZINK 소개오늘날의 데이터 중심 사회에서 개인 정보를 보호하는 일은 그 어느 때보다 중요해졌습니다. 기업과 기관들은 고객 데이터를 수집하고 분석하는 과정에서, 법적·윤리적 책임을 피하기 위해 민감한 정보를 비식별화하는 기술을 적극적으로 도입하고 있습니다. 특히 자연어 데이터의 경우, 이름, 주소, 직업, 전화번호 등 다양한 형태의 민감정보가 포함될 수 있어 정교한 처리 기술이 필요합니다.ZINK는 이러한 요구에 대응하여 개발된 파이썬 기반의 오픈소스 라이브러리로, 사전 학습이나 별도의 데이터 없이도 텍스트에서 민감정보를 탐지하고 제거 혹은 교체할 수 있는 ‘제로샷 비식별화’ 기능을 제공합니다. 사용자가 지정한 엔티티 레이블을 기준으로 동작하며, 쉽게 파이썬 프로젝트에 통합할 수 있도록 간단한 API를 제공합니다.최근 ZINK는 0.4 버전부터 NER(Named Entity Recognition) 모델을 ONNX 버전으로 전환함으로써 처리 속도와 효율성을 크게 향상시켰으며, Faker 라이브러리를 이용한 더 자연스러운 데이터 대체 기능도 새롭게 추가되었습니다. 이러한 기능들은 연구용 데이터 전처리, AI 모델 학습용 텍스트 준비, 의료나 금융 데이터의 비식별화 등 다양한 상황에 적용할 수 있는 유연함을 제공합니다.기존의 엔티티 인식 기반 비식별화 시스템들은 대부분 사전 학습된 모델이나 특정 도메인 데이터셋에 의존하는 구조입니다. 예를 들어, SpaCy나 Stanza는 고정된 엔티티 종류를 감지하는 데는 탁월하지만, 커스텀 엔티티나 유연한 대응이 어렵습니다. 반면, GPT 기반 LLM은 유연성과 정확성 면에서 뛰어나지만, 연산 자원이 많이 들고 비용이 높다는 단점이 있습니다.ZINK는 이 두 방식의 장점을 흡수하고 단점을 보완하기 위해 ‘제로샷 NER’을 택했습니다. 사용자가 단지 감지하고 싶은 엔티티 이름을 텍스트와 함께 입력하면, 내부적으로 GLiNER와 NuNER Zero 같은 모델이 이를 분석하고 대응합니다. 이러한 접근은 LLM보다 훨씬 가볍고 빠르며, 기존 NER보다 훨씬 유연합니다.ZINK 설치 및 사용법ZINK 설치 방법ZINK는pip install zink명령어만으로 간단히 설치할 수 있습니다. 설치 후, zink 모듈을 임포트하여 다양한 형태의 텍스트 비식별화를 수행할 수 있습니다.pip install zink엔티티 삭제 기능 (Redact)redact 함수는 감지된 엔티티를 [LABEL]_REDACTED 형식으로 치환합니다. 예를 들어, 아래 예시와 같이 person, profession, sport, car 엔티티를 지정하면 텍스트에서 해당 정보를 제거합니다.import zink as zn\n\ntext = \"John works as a doctor and plays football after work and drives a toyota.\"\nlabels = (\"person\", \"profession\", \"sport\", \"car\")\nresult = zn.redact(text, labels)\nprint(result.anonymized_text)\n# 결과: person_REDACTED works as a profession_REDACTED and plays sport_REDACTED after work and drives a car_REDACTED.엔티티 교체 기능 (Replace)replace 함수는 감지된 엔티티를 같은 유형의 무작위 값으로 대체합니다. 이는 분석이나 테스트 목적의 데이터 변환에 매우 유용합니다.text = \"John Doe dialled his mother at 992-234-3456 and then went out for a walk.\"\nlabels = (\"person\", \"phone number\", \"relationship\")\nresult = zn.replace(text, labels)\nprint(result.anonymized_text)\n# 예시 출력: Warren Buffet dialled his Uncle at 2347789287 and then went out for a walk.사용자 지정 데이터로 교체자체 데이터셋을 활용하여 특정 엔티티를 직접 지정한 값으로 대체할 수 있습니다.text = \"Melissa works at Google and drives a Tesla.\"\nlabels = (\"person\", \"company\", \"car\")\ncustom_replacements = {\n    \"person\": \"Alice\",\n    \"company\": \"OpenAI\",\n    \"car\": (\"Honda\", \"Toyota\")\n}\nresult = zn.replace_with_my_data(text, labels, user_replacements=custom_replacements)\nprint(result.anonymized_text)\n# 출력 예: Alice works at OpenAI and drives a Honda.ZINK의 내부 구성 및 기술적 배경GLiNERGLiNER는 BERT와 유사한 양방향 Transformer 기반 NER 모델로, 사전 정의된 엔티티 종류에 얽매이지 않고 자유로운 엔티티 감지가 가능합니다. 특히 LLM 대비 연산 자원 소모가 적고, 기존 NER보다 유연하게 다양한 텍스트를 처리할 수 있습니다.github.comGitHub - urchade/GLiNER: Generalist and Lightweight Model for Named Entity...Generalist and Lightweight Model for Named Entity Recognition (Extract any entity types from texts) @ NAACL 2024NuNER ZeroNuNER_Zero는 GLiNER 기반으로 훈련된 고성능 경량 모델입니다. 엔티티 라벨을 소문자로 통일하고, 라벨과 텍스트를 하나로 합쳐 입력으로 사용합니다. NuNER v2.0 데이터셋에서 학습되었으며, GLiNER-large보다도 3% 이상 높은 F1-score를 보입니다.huggingface.conumind/NuNER_Zero · Hugging FaceWe’re on a journey to advance and democratize artificial intelligence through open source and open science.Faker 통합 기능Faker 라이브러리를 활용하여 현실적인 가짜 데이터를 생성합니다. 이름, 날짜, 국가, 직업 등의 엔티티에 대해 상황에 맞는 교체값을 생성할 수 있으며, 특정 위치나 날짜 형식 등도 고려하여 정교하게 작동합니다.위치 처리: 외부 파일에서 국가 이름 목록을 읽어, 감지된 국가명을 임의의 다른 국가로 교체날짜 처리: 숫자형 날짜는 Faker로 생성, 문자형은 사용자 정의 방식 적용역할 인식: 의사, 환자 등 인간 역할을 인식해 맥락에 맞는 이름으로 교체faker.readthedocs.ioWelcome to Faker’s documentation! — Faker 37.4.0 documentation테스트 및 기여 방법프로젝트 루트에서 pytest 명령어로 테스트를 실행할 수 있습니다. Pull Request나 이슈 등록을 통해 프로젝트 개선에 기여할 수 있습니다.라이선스ZINK 프로젝트는Apache 2.0 라이선스로 공개 및 배포 되고 있습니다. 상업적 사용에 제한이 없으며, 자유롭게 수정 및 재배포가 가능합니다.ZINK 프로젝트 GitHub 저장소github.comGitHub - deepanwadhwa/zink: A Python package for zero-shot text anonymization...A Python package for zero-shot text anonymization using Transformer-based NER models.ZINK 공식 문서 사이트zink.readthedocs.ioZINK (Zero-shot Ink) — Zink 0.4.1 documentation이 글은 GPT 모델로 정리한 글을 바탕으로 한 것으로, 원문의 내용 또는 의도와 다르게 정리된 내용이 있을 수 있습니다. 관심있는 내용이시라면 원문도 함께 참고해주세요! 읽으시면서 어색하거나 잘못된 내용을 발견하시면 덧글로 알려주시기를 부탁드립니다.파이토치 한국 사용자 모임이 정리한 이 글이 유용하셨나요?회원으로 가입하시면 주요 글들을 이메일로 보내드립니다! (기본은 Weekly지만Daily로 변경도 가능합니다.)아래쪽에 좋아요를 눌러주시면 새로운 소식들을 정리하고 공유하는데 힘이 됩니다~",
        "summary": "ZINK는 제로샷 학습 방식을 이용해 텍스트 내 민감 정보를 비식별화하는 파이썬 기반 오픈소스 라이브러리입니다.  사전 학습이나 추가 데이터 없이 사용자가 지정한 엔티티를 탐지하고 제거 또는 다른 값으로 대체하며,  GLiNER와 NuNER Zero 모델을 활용하여 속도와 효율성을 높였습니다.  쉽게 설치 및 사용 가능하며,  다양한 데이터 처리 및 비식별화 작업에 활용될 수 있습니다.\n"
    },
    {
        "title": "Portkey AI Gateway: 여러 AI 모델들을 빠르고 신뢰성있게 라우팅하는 오픈소스 솔루션",
        "url": "https://discuss.pytorch.kr/t/portkey-ai-gateway-ai/7205",
        "source": "pytorch_kr",
        "body": "Portkey AI Gateway: 여러 AI 모델들을 빠르고 신뢰성있게 라우팅하는 오픈소스 솔루션1860×514 68.9 KBPortkey AI Gateway 소개AI 모델을 실제 서비스에 적용하고 운영하는 과정에서 가장 중요한 과제 중 하나는 ‘안정성’과 ‘유연성’입니다. 특히 다양한 LLM(Large Language Model)을 동시에 다루거나, 서비스 장애에 대비한 자동 재시도, 로드 밸런싱, 또는 멀티모달 처리까지 고려해야 할 요소가 많습니다. 이러한 현실 속에서 Portkey-AI의 오픈소스 프로젝트인AI Gateway는 이러한 복잡한 요구사항을 효과적으로 해결하기 위한 솔루션으로 주목받고 있습니다.image1028×677 37.4 KBPortkey AI Gateway는 단일 API를 통해 200개 이상의 LLM 제공자(OpenAI, Google Gemini, Anthropic, Mistral 등)와 연결할 수 있는 경량화된 오픈소스 게이트웨이입니다. 주요 특징은 빠른 응답 속도(1ms 이하), 뛰어난 확장성, 신뢰도 높은 자동 재시도 및 폴백(fallback) 처리, 보안 중심의 데이터 검증 기능 등입니다. 특히 122KB에 불과한 작은 크기로도 대규모 운영 환경에서도 1일 수십억 토큰 수준의 처리 성능을 보유하고 있습니다.많은 기업과 개발자들이 LLM 애플리케이션을 구축하면서 발생하는 가장 큰 문제 중 하나는 벤더 락인과 관리 복잡성입니다. AI Gateway는 이러한 문제에 대해 “라우팅”이라는 해결책을 제시합니다. 사용자는 자신의 키를 통해 다양한 LLM을 조건에 따라 선택적으로 호출할 수 있고, 비즈니스 상황에 맞춰 손쉽게 전환하거나 확장할 수 있습니다.Portkey AI Gateway는 단순한 프록시 API가 아닌,자동 재시도,조건 기반 라우팅,보안 검증,멀티모달 지원,스마트 캐싱등 일반적인 프록시 솔루션이나 API 게이트웨이보다 한층 더 AI 친화적인 기능을 제공합니다. 기존의 OpenAI SDK, LangChain, Autogen, CrewAI 등과도 원활하게 통합되며, AWS, GCP, Azure 등 다양한 클라우드 환경에서도 엔터프라이즈 수준의 배포가 가능합니다.Portkey AI Gateway의 주요 기능빠른 설치 및 첫 호출 예제npx패키지 매니저로 로컬에서 바로 실행할 수 있는 CLI 명령은 아래와 같습니다:npx @portkey-ai/gateway설치 후에는 localhost:8787에서 API와 콘솔 인터페이스가 실행됩니다. Gateway Console은http://localhost:8787/public/에서 확인할 수 있습니다.또는,pip를 사용하여 Python SDK를 설치한 뒤, 아래와 같이 간단한 채팅 요청을 보낼 수 있습니다:# Python SDK 설치\npip install -qU portkey-ai# Portkey AI Gateway 사용 예제\nfrom portkey_ai import Portkey\nclient = Portkey(provider=\"openai\", Authorization=\"sk-***\")\nclient.chat.completions.create(\n    messages=[{\"role\": \"user\", \"content\": \"What's the weather like?\"}],\n    model=\"gpt-4o-mini\"\n)라우팅 설정 및 보안 가드레일사용자는 config를 통해 요청 재시도 설정, 응답 검열, 키워드 필터링 등의 동작을 손쉽게 설정할 수 있습니다.config = {\n  \"retry\": {\"attempts\": 5},\n  \"output_guardrails\": [{\n    \"default.contains\": {\"operator\": \"none\", \"words\": [\"Apple\"]},\n    \"deny\": True\n  }]\n}\n\n# 설정한 config를 client에 적용\nclient = client.with_options(config=config)\n\nclient.chat.completions.create(\n    model=\"gpt-4o-mini\",\n    messages=[{\"role\": \"user\", \"content\": \"Reply randomly with Apple or Bat\"}]\n)이러한 설정을 통해 요청 실패 시 자동 재시도하거나, 민감 단어를 필터링해 보안을 강화할 수 있습니다. 더 많은 예시들은Portkey Wiki에서 확인하실 수 있습니다.엔터프라이즈 기능기업 사용자들을 위한 기능으로는 다음과 같은 고급 기능이 제공됩니다:키 관리 및 접근 제어IP 및 지역 기반 접근 제한개인정보 자동 마스킹SOC2, HIPAA, GDPR, ISO 보안 인증멀티모달 및 에이전트 프레임워크 연동텍스트 외에도 이미지 생성, 음성 인식, 음성 합성 등 멀티모달 LLM도 지원합니다. 또한 Autogen, LangChain, CrewAI, LlamaIndex 등의 프레임워크와도 통합되며, 복잡한 Agent 워크플로우를 간편하게 구성할 수 있습니다.라이선스Portkey AI Gateway 프로젝트는MIT 라이선스로 공개되어 있으며, 상업적 사용과 수정, 재배포에 제한이 없습니다.Portkey AI Gateway 프로젝트 GitHub 저장소github.comGitHub - Portkey-AI/gateway: A blazing fast AI Gateway with integrated...A blazing fast AI Gateway with integrated guardrails. Route to 200+ LLMs, 50+ AI Guardrails with 1 fast & friendly API.Portkey Wikiportkey.aiProduction Stack for Gen AI Builders|PortkeyDemocratize and productionize Gen AI across your entire org with Portkey's suite of AI gateway, observability, guardrails, and prompt management modules.이 글은 GPT 모델로 정리한 글을 바탕으로 한 것으로, 원문의 내용 또는 의도와 다르게 정리된 내용이 있을 수 있습니다. 관심있는 내용이시라면원문도 함께 참고해주세요! 읽으시면서 어색하거나 잘못된 내용을 발견하시면 덧글로 알려주시기를 부탁드립니다.파이토치 한국 사용자 모임이 정리한 이 글이 유용하셨나요?회원으로 가입하시면 주요 글들을 이메일로 보내드립니다! (기본은 Weekly지만Daily로 변경도 가능합니다.)아래쪽에 좋아요를 눌러주시면 새로운 소식들을 정리하고 공유하는데 힘이 됩니다~",
        "summary": "Portkey AI Gateway는 200개 이상의 LLM 제공자와 연결하는 경량의 오픈소스 AI 게이트웨이로, 빠른 속도와 확장성, 안정적인 자동 재시도 기능을 제공합니다.  다양한 LLM을 단일 API로 관리하고, 사용자 정의 라우팅 및 보안 기능(키워드 필터링, 접근 제어 등)을 통해 벤더 종속 및 관리 복잡성을 해결합니다.  MIT 라이선스로 공개되어 있으며, 멀티모달 지원과 기존 AI 프레임워크와의 통합을 통해 기업 수준의 AI 애플리케이션 구축을 지원합니다.\n"
    },
    {
        "title": "[2025/06/23 ~ 29] 이번 주에 살펴볼 만한 AI/ML 논문 모음",
        "url": "https://discuss.pytorch.kr/t/2025-06-23-29-ai-ml/7181",
        "source": "pytorch_kr",
        "body": "[2025/06/23 ~ 29] 이번 주에 살펴볼 만한 AI/ML 논문 모음PyTorchKR​이번 주 선정된 논문들을 살펴보면, 첫째로 멀티에이전트 협업과 경험 축적을 통한 추론 능력 강화에 대한 연구가 두드러집니다. 예를 들어, Xolver는 올림피아드 팀처럼 다양한 경험과 협업을 통해 문제 해결 능력을 높이는 프레임워크를 제안하며, MEM1은 장기 대화 상황에서 효율적인 메모리 관리와 추론을 동시에 수행하는 강화학습 기반 방법을 소개합니다. 이러한 연구들은 기존의 독립적인 문제 해결 방식에서 벗어나, 경험을 누적하고 동료 에이전트와 상호작용하며 점진적으로 성능을 향상시키는 방향으로 AI 에이전트의 추론 능력을 발전시키려는 흐름을 반영합니다.둘째, 멀티모달 AI, 특히 시각과 언어를 결합한 모델들의 발전이 두드러집니다. Visionary-R1과 Griffon-R 같은 모델들은 시각적 질문응답과 복잡한 시각 추론 문제를 해결하기 위해 강화학습과 인간과 유사한 이해-사고-응답 프로세스를 도입합니다. 또한, 시각적 표현과 언어 표현 간의 정렬 메커니즘을 분석하는 연구도 포함되어 있어, 멀티모달 모델의 내재적 작동 원리를 이해하고 최적화하려는 시도가 활발함을 알 수 있습니다. 이러한 연구들은 멀티모달 AI가 단순한 인식 수준을 넘어 고차원적 추론과 응용으로 확장되고 있음을 보여줍니다.마지막으로, 장기적이고 복잡한 입력을 효율적으로 처리하기 위한 메모리 및 토큰 선택 기법에 관한 연구가 눈에 띕니다. MEM1은 장기 대화에서 메모리 사용량을 일정하게 유지하면서도 성능을 향상시키는 방법을 제시하고, FlexSelect는 긴 영상 데이터에서 핵심 정보를 선별하여 처리 효율을 극대화합니다. 또한, 비디오 LLM 훈련에서 영상 데이터의 중요성과 한계를 분석하는 연구도 포함되어 있어, 대규모 시퀀스 데이터 처리의 효율성과 효과성 개선이 AI 연구의 중요한 과제로 자리잡고 있음을 시사합니다. 이처럼 장기 기억과 효율적 정보 선택은 AI 모델의 실용성과 확장성을 높이는 데 필수적인 요소로 부각되고 있습니다.Xolver: 올림피아드 팀처럼 전체 경험 학습을 통한 다중 에이전트 추론 / Xolver: Multi-Agent Reasoning with Holistic Experience Learning Just Like an Olympiad TeamXolver: 올림피아드 팀처럼 전체 경험 학습을 통한 다중 에이전트 추론 / Xolver: Multi-Agent Reasoning with Holistic Experience Learning Just Like an Olympiad Team2266×1060 353 KB논문 소개Xolver는 기존 대형 언어 모델(LLM)이 문제를 독립적으로 처리하는 한계를 극복하고, 올림피아드 팀과 같이 다양한 경험을 통합하여 지속적이고 진화하는 메모리를 활용하는 다중 에이전트 추론 프레임워크입니다. 외부 및 자기 검색, 도구 활용, 협업 상호작용, 에이전트 주도 평가, 반복적 개선 등 다양한 경험 방식을 결합하여 추론 시점에 전략, 코드 조각, 추상적 추론 패턴을 학습함으로써 문제 해결을 처음부터 생성하는 방식을 지양합니다. 경량 모델에서도 최첨단 대형 모델을 능가하는 성능을 보이며, 수학 및 코딩 벤치마크에서 최고 성과를 기록하여 전문적 수준의 추론이 가능한 범용 에이전트 개발에 중요한 진전을 제시합니다.논문 초록(Abstract)복잡한 추론 분야에서 눈에 띄는 발전에도 불구하고, 현재의 대형 언어 모델(LLM)은 일반적으로 독립적으로 작동하며, 각 문제를 별개의 시도로 처리하고 경험적 지식을 축적하거나 통합하지 않습니다. 반면, 올림피아드나 프로그래밍 대회 팀과 같은 전문가 문제 해결자는 코치로부터의 멘토링을 흡수하고, 과거 문제들로부터 직관을 개발하며, 도구 사용법과 라이브러리 기능에 대한 지식을 활용하고, 동료들의 전문성과 경험에 기반해 전략을 조정하며, 시행착오를 통해 추론을 지속적으로 개선하고, 대회 중에도 관련된 다른 문제들로부터 학습하는 등 풍부한 경험의 망을 활용합니다. 본 논문에서는 블랙박스 LLM에 전체적 경험의 지속적이고 진화하는 메모리를 부여하는 학습 불필요 다중 에이전트 추론 프레임워크인 Xolver를 제안합니다. Xolver는 외부 및 자기 검색, 도구 사용, 협업 상호작용, 에이전트 주도 평가, 반복적 개선 등 다양한 경험 양식을 통합합니다. 추론 시점에 관련 전략, 코드 조각, 추상적 추론 패턴으로부터 학습함으로써 Xolver는 솔루션을 처음부터 생성하는 것을 피하며, 독립적 추론에서 경험 인지 언어 에이전트로의 전환을 의미합니다. 오픈 웨이트 및 독점 모델 모두에 기반한 Xolver는 전문화된 추론 에이전트들을 지속적으로 능가합니다. 경량 백본(QWQ-32B 등)에서도 Qwen3-235B, Gemini 2.5 Pro, o3, o4-mini-high 등 고급 모델을 자주 능가합니다. o3-mini-high와 함께 GSM8K(98.1%), AIME'24(94.4%), AIME'25(93.7%), Math-500(99.8%), LiveCodeBench-V5(91.6%)에서 새로운 최고 성과를 달성하며, 전체적 경험 학습이 전문가 수준의 추론이 가능한 범용 에이전트로 나아가는 핵심 단계임을 강조합니다. 코드와 데이터는𝕏olver: Multi-Agent Reasoning with Holistic Experience Learning Just Like an Olympiad Team에서 확인할 수 있습니다.Despite impressive progress on complex reasoning, current large language models (LLMs) typically operate in isolation - treating each problem as an independent attempt, without accumulating or integrating experiential knowledge. In contrast, expert problem solvers - such as Olympiad or programming contest teams - leverage a rich tapestry of experiences: absorbing mentorship from coaches, developing intuition from past problems, leveraging knowledge of tool usage and library functionality, adapting strategies based on the expertise and experiences of peers, continuously refining their reasoning through trial and error, and learning from other related problems even during competition. We introduce Xolver, a training-free multi-agent reasoning framework that equips a black-box LLM with a persistent, evolving memory of holistic experience. Xolver integrates diverse experience modalities, including external and self-retrieval, tool use, collaborative interactions, agent-driven evaluation, and iterative refinement. By learning from relevant strategies, code fragments, and abstract reasoning patterns at inference time, Xolver avoids generating solutions from scratch - marking a transition from isolated inference toward experience-aware language agents. Built on both open-weight and proprietary models, Xolver consistently outperforms specialized reasoning agents. Even with lightweight backbones (e.g., QWQ-32B), it often surpasses advanced models including Qwen3-235B, Gemini 2.5 Pro, o3, and o4-mini-high. With o3-mini-high, it achieves new best results on GSM8K (98.1%), AIME'24 (94.4%), AIME'25 (93.7%), Math-500 (99.8%), and LiveCodeBench-V5 (91.6%) - highlighting holistic experience learning as a key step toward generalist agents capable of expert-level reasoning. Code and data are available at𝕏olver: Multi-Agent Reasoning with Holistic Experience Learning Just Like an Olympiad Team.논문 링크arXiv.orgXolver: Multi-Agent Reasoning with Holistic Experience Learning Just Like an...Despite impressive progress on complex reasoning, current large language models (LLMs) typically operate in isolation - treating each problem as an independent attempt, without accumulating or integrating experiential knowledge. In contrast, expert...더 읽어보기kagnlp.github.io𝕏olver: Multi-Agent Reasoning with Holistic Experience Learning Just Like an...𝕏olver: Multi-Agent Reasoning with Holistic Experience Learning Just Like an Olympiad TeamMEM1: 효율적인 장기 대화 에이전트를 위한 메모리와 추론의 시너지 학습 / MEM1: Learning to Synergize Memory and Reasoning for Efficient Long-Horizon AgentsMEM1: 효율적인 장기 대화 에이전트를 위한 메모리와 추론의 시너지 학습 / MEM1: Learning to Synergize Memory and Reasoning for Efficient Long-Horizon Agents1028×549 82.9 KB논문 소개현대 언어 에이전트는 장기 다중 대화에서 외부 정보를 검색하고 관찰에 적응하며 상호 연관된 질문에 답해야 합니다. 기존 대형언어모델(LLM) 시스템은 모든 과거 대화를 무차별적으로 포함하는 전체 문맥 프롬프트 방식을 사용해 메모리 사용량이 무한히 증가하고 계산 비용이 높아지며, 분포 밖 입력 길이에서는 추론 성능이 저하되는 문제가 있습니다. MEM1은 강화학습 기반의 프레임워크로, 매 턴마다 관련 없는 정보를 전략적으로 버리면서 이전 기억과 새로운 관찰을 통합하는 압축된 내부 상태를 유지하여 일정한 메모리 사용량으로 장기 다중 대화 작업을 수행할 수 있게 합니다. 다양한 도메인에서 MEM1은 기존 모델 대비 추론 성능을 크게 향상시키고 메모리 사용을 대폭 줄이며, 훈련 시의 대화 길이를 넘어서는 일반화 능력도 입증하였습니다.논문 초록(Abstract)현대의 언어 에이전트는 장기적이고 다중 턴으로 이루어진 상호작용에서 외부 정보를 검색하고, 관찰에 적응하며, 상호 의존적인 질의에 답변해야 합니다. 그러나 대부분의 LLM 시스템은 관련성에 관계없이 모든 과거 턴을 덧붙이는 전체 문맥 프롬프팅에 의존합니다. 이는 무한한 메모리 증가, 계산 비용 상승, 그리고 분포 밖 입력 길이에 대한 추론 성능 저하를 초래합니다. 본 논문에서는 MEM1을 제안합니다. MEM1은 장기 다중 턴 작업에서 일정한 메모리 사용량으로 에이전트가 동작할 수 있도록 하는 종단 간 강화학습 프레임워크입니다. 각 턴마다 MEM1은 메모리 통합과 추론을 동시에 지원하는 간결한 공유 내부 상태를 갱신합니다. 이 상태는 이전 메모리와 환경으로부터의 새로운 관찰을 통합하며, 관련 없거나 중복된 정보를 전략적으로 폐기합니다. 보다 현실적이고 구성적인 학습 환경을 지원하기 위해, 기존 데이터셋을 조합하여 임의로 복잡한 작업 시퀀스를 구성하는 간단하면서도 효과적이고 확장 가능한 다중 턴 환경 구축 방식을 제안합니다. 내부 검색 QA, 개방형 웹 QA, 다중 턴 웹 쇼핑 등 세 가지 도메인에서의 실험 결과, MEM1-7B는 16개 목표의 다중 홉 QA 작업에서 Qwen2.5-14B-Instruct 대비 성능을 3.5배 향상시키고 메모리 사용량은 3.7배 절감하였으며, 학습 범위를 넘어 일반화됨을 확인하였습니다. 본 연구 결과는 효율성과 성능을 동시에 최적화하는 장기 상호작용 에이전트 학습을 위한 확장 가능한 대안으로서, 추론 중심 메모리 통합의 가능성을 보여줍니다.Modern language agents must operate over long-horizon, multi-turn interactions, where they retrieve external information, adapt to observations, and answer interdependent queries. Yet, most LLM systems rely on full-context prompting, appending all past turns regardless of their relevance. This leads to unbounded memory growth, increased computational costs, and degraded reasoning performance on out-of-distribution input lengths. We introduce MEM1, an end-to-end reinforcement learning framework that enables agents to operate with constant memory across long multi-turn tasks. At each turn, MEM1 updates a compact shared internal state that jointly supports memory consolidation and reasoning. This state integrates prior memory with new observations from the environment while strategically discarding irrelevant or redundant information. To support training in more realistic and compositional settings, we propose a simple yet effective and scalable approach to constructing multi-turn environments by composing existing datasets into arbitrarily complex task sequences. Experiments across three domains, including internal retrieval QA, open-domain web QA, and multi-turn web shopping, show that MEM1-7B improves performance by 3.5x while reducing memory usage by 3.7x compared to Qwen2.5-14B-Instruct on a 16-objective multi-hop QA task, and generalizes beyond the training horizon. Our results demonstrate the promise of reasoning-driven memory consolidation as a scalable alternative to existing solutions for training long-horizon interactive agents, where both efficiency and performance are optimized.논문 링크arXiv.orgMEM1: Learning to Synergize Memory and Reasoning for Efficient Long-Horizon...Modern language agents must operate over long-horizon, multi-turn interactions, where they retrieve external information, adapt to observations, and answer interdependent queries. Yet, most LLM systems rely on full-context prompting, appending all...GSO: SWE-에이전트 평가를 위한 도전적 소프트웨어 최적화 과제 / GSO: Challenging Software Optimization Tasks for Evaluating SWE-AgentsGSO: SWE-에이전트 평가를 위한 도전적 소프트웨어 최적화 과제 / GSO: Challenging Software Optimization Tasks for Evaluating SWE-Agents964×385 72.4 KB논문 소개GSO는 고성능 소프트웨어 개발 능력을 평가하기 위한 벤치마크로, 10개 코드베이스에서 102개의 어려운 최적화 과제를 자동으로 생성하고 성능 테스트를 수행합니다. 에이전트는 코드베이스와 성능 테스트를 받아 런타임 효율성을 개선하는 과제를 수행하며, 전문가 최적화와 비교하여 평가됩니다. 주요 SWE-Agents는 5% 미만의 낮은 성공률을 보였고, 추론 시간 확장에도 성능 향상이 제한적이었습니다. 분석 결과, 저수준 언어 처리, 소극적 최적화 전략, 병목 구간 정확한 파악의 어려움이 주요 실패 원인으로 나타났습니다.논문 초록(Abstract)고성능 소프트웨어 개발은 전문적인 지식을 요구하는 복잡한 과제입니다. 본 논문에서는 언어 모델의 고성능 소프트웨어 개발 역량을 평가하기 위한 벤치마크인 GSO를 제안합니다. 우리는 저장소 커밋 이력을 분석하여 10개의 코드베이스에 걸쳐 다양한 도메인과 프로그래밍 언어를 포함하는 102개의 도전적인 최적화 과제를 식별하고, 성능 테스트를 자동으로 생성 및 실행하는 파이프라인을 개발하였습니다. 에이전트는 코드베이스와 성능 테스트를 명확한 명세로 제공받아, 전문가 개발자의 최적화와 비교하여 런타임 효율성을 향상시키는 임무를 수행합니다. 정량적 평가 결과, 주요 SWE-Agents는 5% 미만의 성공률을 기록하며, 추론 시 확장에도 불구하고 개선이 제한적임을 확인하였습니다. 정성적 분석에서는 저수준 언어 처리의 어려움, 소극적인 최적화 전략 사용, 병목 현상 정확한 위치 파악의 어려움 등 주요 실패 원인을 규명하였습니다. 본 벤치마크의 코드와 산출물, 에이전트 경로를 공개하여 향후 연구를 지원합니다.Developing high-performance software is a complex task that requires specialized expertise. We introduce GSO, a benchmark for evaluating language models' capabilities in developing high-performance software. We develop an automated pipeline that generates and executes performance tests to analyze repository commit histories to identify 102 challenging optimization tasks across 10 codebases, spanning diverse domains and programming languages. An agent is provided with a codebase and performance test as a precise specification, and tasked to improve the runtime efficiency, which is measured against the expert developer optimization. Our quantitative evaluation reveals that leading SWE-Agents struggle significantly, achieving less than 5% success rate, with limited improvements even with inference-time scaling. Our qualitative analysis identifies key failure modes, including difficulties with low-level languages, practicing lazy optimization strategies, and challenges in accurately localizing bottlenecks. We release the code and artifacts of our benchmark along with agent trajectories to enable future research.논문 링크arXiv.orgGSO: Challenging Software Optimization Tasks for Evaluating SWE-AgentsDeveloping high-performance software is a complex task that requires specialized expertise. We introduce GSO, a benchmark for evaluating language models' capabilities in developing high-performance software. We develop an automated pipeline that...더 읽어보기gso-bench.github.ioGSO: Challenging Software Optimization Tasks for Evaluating SWE-AgentsGSO is a benchmark for evaluating language models' capabilities in developing high-performance software through challenging optimization tasks.통합 멀티모달 사전학습에서 나타나는 신흥 특성 / Emerging Properties in Unified Multimodal Pretraining통합 멀티모달 사전학습에서 나타나는 신흥 특성 / Emerging Properties in Unified Multimodal Pretraining1742×1856 501 KB논문 소개BAGEL은 텍스트, 이미지, 비디오, 웹 데이터를 대규모로 혼합(pretraining)하여 학습한 통합 멀티모달(decoder-only) 기초 모델입니다. 다양한 멀티모달 데이터를 활용함으로써 복잡한 멀티모달 추론 능력에서 뛰어난 성능을 보이며, 기존 공개된 통합 모델 대비 멀티모달 생성과 이해 양쪽에서 우수한 결과를 나타냅니다. 특히 자유형 이미지 조작, 미래 프레임 예측, 3D 조작, 세계 내비게이션 등 고급 멀티모달 추론 기능을 구현합니다. 연구진은 모델 학습 방법, 데이터 생성 프로토콜, 코드와 체크포인트를 공개하여 멀티모달 연구 활성화를 도모하고 있습니다.논문 초록(Abstract)최첨단 독점 시스템에서 멀티모달 이해와 생성을 통합하는 접근법은 뛰어난 성능을 보여주고 있습니다. 본 연구에서는 멀티모달 이해와 생성을 본질적으로 지원하는 오픈소스 기반 모델인 BAGEL을 소개합니다. BAGEL은 대규모로 교차된 텍스트, 이미지, 비디오, 웹 데이터를 기반으로 수조 개의 토큰에 대해 사전학습된 통합형 디코더 전용 모델입니다. 이렇게 다양한 멀티모달 교차 데이터를 활용하여 확장할 때, BAGEL은 복잡한 멀티모달 추론에서 새로운 능력을 발휘합니다. 그 결과, 표준 벤치마크에서 멀티모달 생성과 이해 모두에서 오픈소스 통합 모델을 크게 능가하며, 자유형 이미지 조작, 미래 프레임 예측, 3D 조작, 세계 내비게이션과 같은 고급 멀티모달 추론 능력도 보여줍니다. 멀티모달 연구의 추가 기회를 촉진하고자, 주요 발견사항, 사전학습 세부사항, 데이터 생성 프로토콜을 공유하며, 코드와 체크포인트를 커뮤니티에 공개합니다. 프로젝트 페이지는https://bagel-ai.org/입니다.Unifying multimodal understanding and generation has shown impressive capabilities in cutting-edge proprietary systems. In this work, we introduce BAGEL, an open-source foundational model that natively supports multimodal understanding and generation. BAGEL is a unified, decoder-only model pretrained on trillions of tokens curated from large-scale interleaved text, image, video, and web data. When scaled with such diverse multimodal interleaved data, BAGEL exhibits emerging capabilities in complex multimodal reasoning. As a result, it significantly outperforms open-source unified models in both multimodal generation and understanding across standard benchmarks, while exhibiting advanced multimodal reasoning abilities such as free-form image manipulation, future frame prediction, 3D manipulation, and world navigation. In the hope of facilitating further opportunities for multimodal research, we share the key findings, pretraining details, data creation protocal, and release our code and checkpoints to the community. The project page is athttps://bagel-ai.org/논문 링크arXiv.orgEmerging Properties in Unified Multimodal PretrainingUnifying multimodal understanding and generation has shown impressive capabilities in cutting-edge proprietary systems. In this work, we introduce BAGEL, an open-source foundational model that natively supports multimodal understanding and...더 읽어보기github.comGitHub - ByteDance-Seed/Bagel: Open-source unified multimodal modelOpen-source unified multimodal modelBAGEL – 18 Mar 25BAGEL: Scalable Unified Multimodal ModelA scalable unified multimodal model, revolutionizing how AI interacts with complex systems.huggingface.coByteDance-Seed/BAGEL-7B-MoT · Hugging FaceWe’re on a journey to advance and democratize artificial intelligence through open source and open science.Visionary-R1: 강화학습을 통한 시각적 추론의 지름길 문제 완화 / Visionary-R1: Mitigating Shortcuts in Visual Reasoning with Reinforcement LearningVisionary-R1: 강화학습을 통한 시각적 추론의 지름길 문제 완화 / Visionary-R1: Mitigating Shortcuts in Visual Reasoning with Reinforcement Learning1661×1225 497 KB논문 소개본 연구에서는 시각 언어 모델(VLM)에 강화학습을 적용하여 명시적인 사고 연쇄(chain-of-thought, CoT) 지도 없이 이미지 기반 추론 능력을 향상시키고자 하였습니다. 단순히 강화학습으로 추론 과정을 유도할 경우 쉬운 문제에서 편법(shortcut)이 발생하여 일반화 성능이 저하되는 문제를 발견하였습니다. 이를 해결하기 위해 이미지에 대한 상세한 캡션 생성 후 추론 과정을 거쳐 답변을 도출하는 캡션-추론-답변(caption-reason-answer) 출력 형식을 도입하였습니다. 27만 3천 개의 CoT 비지도 시각 질문-답변 쌍으로 학습한 Visionary-R1 모델은 GPT-4o, Claude3.5-Sonnet, Gemini-1.5-Pro 등 강력한 다중모달 모델들을 여러 시각 추론 벤치마크에서 능가하는 성과를 보였습니다.논문 초록(Abstract)일반 목적의 추론 능력 학습은 AI 분야에서 오랫동안 어려운 문제로 남아있었습니다. DeepSeek-R1과 같은 대형 언어 모델(LLM) 연구에서는 GRPO와 같은 강화 학습 기법이 사전 학습된 LLM이 단순한 질문-답변 쌍을 통해 추론 능력을 개발할 수 있음을 보여주었습니다. 본 논문에서는 명시적인 사고의 연쇄(CoT) 감독 없이 강화 학습과 시각적 질문-답변 쌍을 활용하여 시각 언어 모델(VLM)이 이미지 데이터에 대해 추론을 수행하도록 학습하는 것을 목표로 합니다. 연구 결과, 단순히 VLM에 강화 학습을 적용하여 답변 전에 추론 과정을 생성하도록 유도하는 경우, 모델이 쉬운 질문에서 지름길(shortcut)을 학습하여 미지의 데이터 분포에 대한 일반화 능력이 저하되는 현상이 나타났습니다. 우리는 이러한 지름길 학습을 완화하는 핵심이 모델이 추론 전에 이미지를 해석하도록 유도하는 데 있다고 주장합니다. 따라서 본 연구에서는 모델이 캡션-추론-답변 출력 형식을 준수하도록 학습하는데, 먼저 이미지에 대한 상세한 캡션을 생성한 후 광범위한 추론 과정을 구성하도록 하였습니다. 273K 개의 CoT 비사용 시각적 질문-답변 쌍으로만 강화 학습을 수행한 결과, Visionary-R1이라 명명한 본 모델은 GPT-4o, Claude3.5-Sonnet, Gemini-1.5-Pro와 같은 강력한 멀티모달 모델들을 여러 시각 추론 벤치마크에서 능가하는 성능을 보였습니다.Learning general-purpose reasoning capabilities has long been a challenging problem in AI. Recent research in large language models (LLMs), such as DeepSeek-R1, has shown that reinforcement learning techniques like GRPO can enable pre-trained LLMs to develop reasoning capabilities using simple question-answer pairs. In this paper, we aim to train visual language models (VLMs) to perform reasoning on image data through reinforcement learning and visual question-answer pairs, without any explicit chain-of-thought (CoT) supervision. Our findings indicate that simply applying reinforcement learning to a VLM -- by prompting the model to produce a reasoning chain before providing an answer -- can lead the model to develop shortcuts from easy questions, thereby reducing its ability to generalize across unseen data distributions. We argue that the key to mitigating shortcut learning is to encourage the model to interpret images prior to reasoning. Therefore, we train the model to adhere to a caption-reason-answer output format: initially generating a detailed caption for an image, followed by constructing an extensive reasoning chain. When trained on 273K CoT-free visual question-answer pairs and using only reinforcement learning, our model, named Visionary-R1, outperforms strong multimodal models, such as GPT-4o, Claude3.5-Sonnet, and Gemini-1.5-Pro, on multiple visual reasoning benchmarks.논문 링크arXiv.orgVisionary-R1: Mitigating Shortcuts in Visual Reasoning with Reinforcement...Learning general-purpose reasoning capabilities has long been a challenging problem in AI. Recent research in large language models (LLMs), such as DeepSeek-R1, has shown that reinforcement learning techniques like GRPO can enable pre-trained LLMs to...더 읽어보기github.comGitHub - maifoundations/Visionary-R1: Mitigating Shortcuts in Visual Reasoning with...Mitigating Shortcuts in Visual Reasoning with Reinforcement Learning멀티모달 LLM에서 시각 표현이 언어 특징 공간에 매핑되는 방식 연구 / How Visual Representations Map to Language Feature Space in Multimodal LLMs논문 소개멀티모달 추론의 효과는 시각 및 언어 표현의 정렬(alignment)에 달려 있으나, 시각-언어 모델(VLM)이 이를 어떻게 달성하는지는 명확하지 않습니다. 본 연구는 고정된 대형 언어 모델(LLM)과 고정된 비전 트랜스포머(ViT)를 선형 어댑터(linear adapter)로만 연결하여 시각적 명령 조정(visual instruction tuning)을 수행하는 방법론적 틀을 제안합니다. 이를 통해 시각 특징이 LLM의 기존 언어 표현 공간으로 직접 매핑되는 과정을 분석할 수 있으며, 사전학습된 희소 오토인코더(SAE)를 활용해 계층별 시각-언어 표현 정렬 과정을 체계적으로 탐구합니다. 결과적으로, 시각 표현은 중간~후반부 LLM 계층에서 언어 표현과 점진적으로 정렬되며, 초기 LLM 계층과 ViT 출력 간에는 근본적인 불일치가 존재함을 밝혀 어댑터 기반 구조의 한계를 시사합니다.논문 초록(Abstract)효과적인 멀티모달 추론은 시각적 표현과 언어적 표현의 정렬에 달려 있으나, 비전-언어 모델(VLM)이 이러한 정렬을 달성하는 메커니즘은 아직 명확히 이해되지 않고 있습니다. 본 논문에서는 대형 언어 모델(LLM)과 비전 트랜스포머(ViT)를 모두 고정(frozen)한 상태로 유지하고, 시각적 지시 학습(visual instruction tuning) 중에 선형 어댑터(linear adapter)만 학습시키는 방법론적 프레임워크를 제안합니다. 이 설계는 본 접근법의 핵심으로, 언어 모델을 고정함으로써 시각 데이터에 적응하지 않고 원래의 언어 표현을 유지하도록 보장합니다. 따라서 선형 어댑터는 언어 모델이 미세조정(fine-tuning)을 통해 특화된 시각적 이해를 발전시키는 대신, 시각적 특징을 LLM의 기존 표현 공간으로 직접 매핑해야 합니다. 실험 설계는 LLM의 사전학습된 희소 오토인코더(SAE)를 분석 도구로 활용할 수 있게 하여 독창적입니다. 이 SAE들은 변하지 않은 언어 모델과 완벽히 정렬되어 있으며, 학습된 언어 특징 표현의 스냅샷 역할을 합니다. SAE 재구성 오류, 희소성 패턴, 특징 SAE 설명에 대한 체계적인 분석을 통해, 시각적 표현이 점진적으로 언어 특징 표현과 정렬되어 중간층에서 후반층으로 수렴하는 계층별 진행 과정을 밝혀냈습니다. 이는 ViT 출력과 초기 LLM 층 간의 근본적인 불일치를 시사하며, 현재의 어댑터 기반 아키텍처가 교차 모달 표현 학습을 최적으로 지원하는지에 대한 중요한 의문을 제기합니다.Effective multimodal reasoning depends on the alignment of visual and linguistic representations, yet the mechanisms by which vision-language models (VLMs) achieve this alignment remain poorly understood. We introduce a methodological framework that deliberately maintains a frozen large language model (LLM) and a frozen vision transformer (ViT), connected solely by training a linear adapter during visual instruction tuning. This design is fundamental to our approach: by keeping the language model frozen, we ensure it maintains its original language representations without adaptation to visual data. Consequently, the linear adapter must map visual features directly into the LLM's existing representational space rather than allowing the language model to develop specialized visual understanding through fine-tuning. Our experimental design uniquely enables the use of pre-trained sparse autoencoders (SAEs) of the LLM as analytical probes. These SAEs remain perfectly aligned with the unchanged language model and serve as a snapshot of the learned language feature-representations. Through systematic analysis of SAE reconstruction error, sparsity patterns, and feature SAE descriptions, we reveal the layer-wise progression through which visual representations gradually align with language feature representations, converging in middle-to-later layers. This suggests a fundamental misalignment between ViT outputs and early LLM layers, raising important questions about whether current adapter-based architectures optimally facilitate cross-modal representation learning.논문 링크arXiv.orgHow Visual Representations Map to Language Feature Space in Multimodal LLMsEffective multimodal reasoning depends on the alignment of visual and linguistic representations, yet the mechanisms by which vision-language models (VLMs) achieve this alignment remain poorly understood. Following the LiMBeR framework, we...이해하고 사고하며 답하다: 대형 멀티모달 모델을 활용한 시각 추론의 발전 / Understand, Think, and Answer: Advancing Visual Reasoning with Large Multimodal Models이해하고 사고하며 답하다: 대형 멀티모달 모델을 활용한 시각 추론의 발전 / Understand, Think, and Answer: Advancing Visual Reasoning with Large Multimodal Models1162×588 183 KB논문 소개대규모 멀티모달 모델(Large Multimodal Models, LMMs)은 시각-언어 및 시각 중심 과제에서 뛰어난 성능을 보이나, 복합적 구성 추론(compositional reasoning) 능력 통합에는 한계가 있습니다. 이를 개선하기 위해, 본 연구는 LMM이 내재된 시각 이해 및 그라운딩(grounding) 능력을 활용하여 복잡한 문제를 한 번의 순전파(forwarding)로 인간과 유사한 이해-사고-응답 과정을 수행하도록 하는 통합 시각 추론 메커니즘을 제안합니다. 또한, 33만 4천 개의 시각 지시문 데이터를 구축하여 다양한 장면과 다중 기초 시각 능력을 포함한 학습을 진행하였으며, 이를 통해 개발된 Griffon-R 모델은 복합 시각 추론 벤치마크에서 우수한 성능을 보이고 다중모달 능력 전반을 향상시켰습니다. 데이터와 모델, 코드는 곧 공개될 예정입니다.논문 초록(Abstract)대규모 멀티모달 모델(LMM)은 최근 비전-언어 및 비전 중심 과제에서 뛰어난 시각 이해 성능을 보여주고 있습니다. 그러나 이들은 복합적 추론을 위한 고급 과제 특화 기능 통합에 있어 한계를 보이며, 진정으로 유능한 일반 비전 모델로 나아가는 데 장애가 되고 있습니다. 이를 해결하기 위해, 본 논문에서는 LMM이 내재된 능력(예: 그라운딩 및 시각 이해 능력)을 활용하여 복잡한 복합 문제를 해결할 수 있는 통합 시각 추론 메커니즘을 제안합니다. 기존의 단축 학습 메커니즘과 달리, 본 접근법은 인간과 유사한 이해-사고-응답 과정을 도입하여, 다중 추론이나 외부 도구 없이 단일 포워딩 과정에서 모든 단계를 완료할 수 있도록 합니다. 이러한 설계는 기초적인 시각 능력과 일반 질의응답 간의 간극을 메우며, LMM이 복잡한 시각 추론에 대해 신뢰할 수 있고 추적 가능한 응답을 생성하도록 유도합니다. 한편, 본 연구에서는 일반 장면과 텍스트가 풍부한 장면을 모두 포함하고 여러 기초 시각 능력을 아우르는 33만 4천 개의 시각 지시 샘플을 선별하였습니다. 학습된 모델인 Griffon-R은 자동 이해, 자기 사고 및 추론 응답의 엔드투엔드(end-to-end) 능력을 갖추고 있습니다. 종합적인 실험 결과, Griffon-R은 VSR 및 CLEVR을 포함한 복잡한 시각 추론 벤치마크에서 뛰어난 성능을 달성할 뿐만 아니라, MMBench 및 ScienceQA와 같은 다양한 벤치마크에서 멀티모달 능력도 향상시켰음을 보여줍니다. 데이터, 모델 및 코드는 곧Griffon/Griffon-R at master · jefferyZhan/Griffon · GitHub에 공개될 예정입니다.Large Multimodal Models (LMMs) have recently demonstrated remarkable visual understanding performance on both vision-language and vision-centric tasks. However, they often fall short in integrating advanced, task-specific capabilities for compositional reasoning, which hinders their progress toward truly competent general vision models. To address this, we present a unified visual reasoning mechanism that enables LMMs to solve complicated compositional problems by leveraging their intrinsic capabilities (e.g. grounding and visual understanding capabilities). Different from the previous shortcut learning mechanism, our approach introduces a human-like understanding-thinking-answering process, allowing the model to complete all steps in a single pass forwarding without the need for multiple inferences or external tools. This design bridges the gap between foundational visual capabilities and general question answering, encouraging LMMs to generate faithful and traceable responses for complex visual reasoning. Meanwhile, we curate 334K visual instruction samples covering both general scenes and text-rich scenes and involving multiple foundational visual capabilities. Our trained model, Griffon-R, has the ability of end-to-end automatic understanding, self-thinking, and reasoning answers. Comprehensive experiments show that Griffon-R not only achieves advancing performance on complex visual reasoning benchmarks including VSR and CLEVR, but also enhances multimodal capabilities across various benchmarks like MMBench and ScienceQA. Data, models, and codes will be release atGriffon/Griffon-R at master · jefferyZhan/Griffon · GitHubsoon.논문 링크arXiv.orgUnderstand, Think, and Answer: Advancing Visual Reasoning with Large...Large Multimodal Models (LMMs) have recently demonstrated remarkable visual understanding performance on both vision-language and vision-centric tasks. However, they often fall short in integrating advanced, task-specific capabilities for...더 읽어보기github.comGriffon/Griffon-R at master · jefferyZhan/GriffonOfficial repo of Griffon series including v1(ECCV 2024), v2, and G - jefferyZhan/GriffonFlexSelect: 효율적인 장기 영상 이해를 위한 유연한 토큰 선택 전략 / FlexSelect: Flexible Token Selection for Efficient Long Video UnderstandingFlexSelect: 효율적인 장기 영상 이해를 위한 유연한 토큰 선택 전략 / FlexSelect: Flexible Token Selection for Efficient Long Video Understanding1661×1233 555 KB논문 소개FlexSelect는 긴 영상 이해를 위한 효율적인 토큰 선택(token selection) 전략으로, 비디오 대형 언어 모델(VideoLLM)의 높은 계산 및 메모리 요구를 줄이는 데 중점을 둡니다. 크로스모달 주의(attention) 패턴을 활용해 의미적으로 중요한 영상 토큰을 식별하고, 훈련이 필요 없는 토큰 랭킹과 이를 모방하는 경량 선택기(rank-supervised selector)를 결합하여 중복 토큰을 효과적으로 필터링합니다. 이 방법은 LLaVA-Video, InternVL, Qwen-VL 등 다양한 VideoLLM에 플러그인 형태로 쉽게 통합 가능하며, 여러 장기 영상 벤치마크에서 성능 향상과 최대 9배의 속도 개선을 입증하였습니다. FlexSelect는 긴 영상 처리에서 계산 효율성과 성능을 동시에 달성할 수 있는 유망한 접근법입니다.논문 초록(Abstract)장기 영상 이해는 매우 높은 계산 및 메모리 요구량으로 인해 비디오 대형 언어 모델(VideoLLM)에게 큰 도전 과제를 제시합니다. 본 논문에서는 장기 영상을 처리하기 위한 유연하고 효율적인 토큰 선택 전략인 FlexSelect를 제안합니다. FlexSelect는 참조 트랜스포머 층에서 추출한 교차 모달 어텐션 패턴을 활용하여 가장 의미론적으로 관련성 높은 콘텐츠를 식별하고 유지합니다. 이 방법은 두 가지 핵심 구성 요소로 이루어져 있습니다: (1) 각 비디오 토큰의 중요도를 추정하기 위해 신뢰할 수 있는 교차 모달 어텐션 가중치를 활용하는 학습 불필요 토큰 랭킹 파이프라인, (2) 이러한 랭킹을 모방하고 중복 토큰을 필터링하도록 학습된 랭크-감독 경량 셀렉터입니다. 이 범용 접근법은 LLaVA-Video, InternVL, Qwen-VL 등 다양한 VideoLLM 아키텍처에 플러그 앤 플레이 모듈로 원활하게 통합되어 시간적 문맥 길이를 확장할 수 있습니다. 실험적으로, FlexSelect는 VideoMME, MLVU, LongVB, LVBench 등 여러 장기 영상 벤치마크에서 뛰어난 성능 향상을 보여줍니다. 또한, LLaVA-Video-7B 모델에서 최대 9배의 속도 향상을 달성하는 등 효율적인 장기 영상 이해를 위한 FlexSelect의 가능성을 입증합니다. 프로젝트 페이지는 다음에서 확인할 수 있습니다:FlexSelectLong-form video understanding poses a significant challenge for video large language models (VideoLLMs) due to prohibitively high computational and memory demands. In this paper, we propose FlexSelect, a flexible and efficient token selection strategy for processing long videos. FlexSelect identifies and retains the most semantically relevant content by leveraging cross-modal attention patterns from a reference transformer layer. It comprises two key components: (1) a training-free token ranking pipeline that leverages faithful cross-modal attention weights to estimate each video token's importance, and (2) a rank-supervised lightweight selector that is trained to replicate these rankings and filter redundant tokens. This generic approach can be seamlessly integrated into various VideoLLM architectures, such as LLaVA-Video, InternVL and Qwen-VL, serving as a plug-and-play module to extend their temporal context length. Empirically, FlexSelect delivers strong gains across multiple long-video benchmarks including VideoMME, MLVU, LongVB, and LVBench. Moreover, it achieves significant speed-ups (for example, up to 9 times on a LLaVA-Video-7B model), highlighting FlexSelect's promise for efficient long-form video understanding. Project page available at:FlexSelect논문 링크arXiv.orgFlexSelect: Flexible Token Selection for Efficient Long Video UnderstandingLong-form video understanding poses a significant challenge for video large language models (VideoLLMs) due to prohibitively high computational and memory demands. In this paper, we propose FlexSelect, a flexible and efficient token selection...더 읽어보기yunzhuzhang0918.github.ioSOCIAL MEDIA TITLE TAGSOCIAL MEDIA DESCRIPTION TAG TAG비디오 LLM 학습에서 비디오의 중요성은 어느 정도일까? / How Important are Videos for Training Video LLMs?비디오 LLM 학습에서 비디오의 중요성은 어느 정도일까? / How Important are Videos for Training Video LLMs?1661×1083 226 KB논문 소개비디오 대형 언어 모델(Video LLMs)은 주로 텍스트 기반 사전학습 모델을 이미지 및 비디오 캡션 데이터로 미세조정하여 개발됩니다. 연구 결과, 이미지 전용 학습만으로도 시간적 추론(temporal reasoning) 능력이 상당히 향상되며, 비디오 특화 학습에서 얻는 성능 향상은 예상보다 미미한 것으로 나타났습니다. 특히, LongVU 알고리즘을 적용한 이미지 학습 모델이 TVBench 벤치마크에서 우수한 성능을 보였고, 주석이 달린 이미지와 질문 시퀀스를 활용한 간단한 미세조정 기법도 비디오 학습 모델과 유사하거나 더 나은 결과를 도출했습니다. 이는 현재 비디오 학습 방식이 실제 비디오의 풍부한 시간적 특성을 충분히 활용하지 못하고 있음을 시사하며, 이미지 학습 모델의 시간적 추론 메커니즘과 비디오 학습의 비효율성에 대한 추가 연구가 필요함을 강조합니다.논문 초록(Abstract)비디오 대형 언어 모델(LLM)에 대한 연구는 최근 몇 년간 급속히 발전하여 수많은 모델과 벤치마크가 등장하였습니다. 일반적으로 이러한 모델들은 사전 학습된 텍스트 전용 LLM으로 초기화된 후 이미지 및 비디오 캡션 데이터셋 모두에 대해 미세 조정됩니다. 본 논문에서는 이미지 전용 학습만으로도 비디오 LLM이 시간적 추론 능력을 예상보다 더 잘 수행하며, 비디오 특화 학습으로 인한 성능 향상은 의외로 미미하다는 점을 발견하였습니다. 구체적으로, 최근 LongVU 알고리즘으로 학습된 두 개의 LLM의 이미지 학습 버전이 시간적 추론 벤치마크인 TVBench에서 우연 수준을 훨씬 상회하는 성과를 보임을 증명합니다. 또한, 시간적 능력을 겨냥한 주석 이미지와 질문 시퀀스를 활용한 간단한 미세 조정 방식을 제안합니다. 이 기본선은 비디오 학습 LLM이 달성하는 성능에 근접하거나 때로는 이를 능가하는 시간적 추론 성능을 나타냅니다. 이는 현 모델들이 실제 비디오에서 발견되는 풍부한 시간적 특징을 최적으로 활용하지 못하고 있음을 시사합니다. 본 분석은 이미지 학습 LLM이 시간적 추론을 수행할 수 있는 메커니즘과 현재 비디오 학습 방식의 비효율성을 초래하는 병목 현상에 대한 추가 연구를 촉진합니다.Research into Video Large Language Models (LLMs) has progressed rapidly, with numerous models and benchmarks emerging in just a few years. Typically, these models are initialized with a pretrained text-only LLM and finetuned on both image- and video-caption datasets. In this paper, we present findings indicating that Video LLMs are more capable of temporal reasoning after image-only training than one would assume, and that improvements from video-specific training are surprisingly small. Specifically, we show that image-trained versions of two LLMs trained with the recent LongVU algorithm perform significantly above chance level on TVBench, a temporal reasoning benchmark. Additionally, we introduce a simple finetuning scheme involving sequences of annotated images and questions targeting temporal capabilities. This baseline results in temporal reasoning performance close to, and occasionally higher than, what is achieved by video-trained LLMs. This suggests suboptimal utilization of rich temporal features found in real video by current models. Our analysis motivates further research into the mechanisms that allow image-trained LLMs to perform temporal reasoning, as well as into the bottlenecks that render current video training schemes inefficient.논문 링크arXiv.orgHow Important are Videos for Training Video LLMs?Research into Video Large Language Models (LLMs) has progressed rapidly, with numerous models and benchmarks emerging in just a few years. Typically, these models are initialized with a pretrained text-only LLM and finetuned on both image- and...더 읽어보기visualcomputinginstitute.github.ioHow Important are Videos for Training Video LLMs?Dolphin: 이종 앵커 프롬프트를 활용한 문서 이미지 파싱 / Dolphin: Document Image Parsing via Heterogeneous Anchor PromptingDolphin: 이종 앵커 프롬프트를 활용한 문서 이미지 파싱 / Dolphin: Document Image Parsing via Heterogeneous Anchor Prompting1659×1485 381 KB논문 소개문서 이미지 파싱은 텍스트, 도형, 수식, 표 등 복잡하게 얽힌 요소들로 인해 어려움이 있습니다. 기존 방법들은 전문 모델을 조합하거나 페이지 단위로 자동 생성하는 방식을 사용하지만, 통합 비용과 효율성 문제, 레이아웃 구조 손상 등의 한계가 존재합니다. Dolphin은 이질적인 앵커(anchor)와 작업별 프롬프트(prompt)를 활용해 먼저 레이아웃 요소를 순서대로 생성한 후, 이를 기반으로 병렬 콘텐츠 파싱을 수행하는 새로운 다중모달 문서 이미지 파싱 모델입니다. 3천만 개 이상의 대규모 데이터셋으로 학습되었으며, 다양한 벤치마크에서 최첨단 성능과 경량화된 구조를 통한 우수한 효율성을 입증하였습니다.논문 초록(Abstract)문서 이미지 파싱은 텍스트 단락, 도형, 수식, 표 등 복잡하게 얽혀 있는 요소들로 인해 매우 어려운 과제입니다. 기존 접근법들은 전문화된 개별 모델들을 조합하거나 페이지 단위 콘텐츠를 자기회귀적으로 직접 생성하는 방식을 사용하지만, 이들은 준수한 성능에도 불구하고 통합 오버헤드, 효율성 병목 현상, 그리고 레이아웃 구조 저하 문제에 직면합니다. 이러한 한계를 극복하기 위해, 본 논문에서는 분석-후-파싱(analyze-then-parse) 패러다임을 따르는 새로운 멀티모달 문서 이미지 파싱 모델인 \\textit{Dolphin}(\\textit{\\textbf{Do}cument Image \\textbf{P}arsing via \\textbf{H}eterogeneous Anchor Prompt\\textbf{in}g})을 제안합니다. 첫 번째 단계에서 Dolphin은 읽기 순서에 따른 레이아웃 요소 시퀀스를 생성합니다. 이 이종 요소들은 앵커(anchor) 역할을 하며, 작업별 프롬프트와 결합되어 두 번째 단계에서 Dolphin에 병렬 콘텐츠 파싱을 위해 다시 입력됩니다. Dolphin 학습을 위해, 다중 세분화 파싱 작업을 포함하는 3천만 개 이상의 대규모 데이터셋을 구축하였습니다. 널리 사용되는 벤치마크와 자체 구축 벤치마크에서의 종합적인 평가를 통해, Dolphin은 다양한 페이지 및 요소 수준 설정에서 최첨단 성능을 달성함과 동시에 경량 아키텍처와 병렬 파싱 메커니즘을 통해 우수한 효율성을 보장합니다. 코드와 사전학습 모델은GitHub - bytedance/Dolphin: The official repo for “Dolphin: Document Image Parsing via Heterogeneous Anchor Prompting”, ACL, 2025.에서 공개되어 있습니다.Document image parsing is challenging due to its complexly intertwined elements such as text paragraphs, figures, formulas, and tables. Current approaches either assemble specialized expert models or directly generate page-level content autoregressively, facing integration overhead, efficiency bottlenecks, and layout structure degradation despite their decent performance. To address these limitations, we present \\textit{Dolphin} (\\textit{\\textbf{Do}cument Image \\textbf{P}arsing via \\textbf{H}eterogeneous Anchor Prompt\\textbf{in}g}), a novel multimodal document image parsing model following an analyze-then-parse paradigm. In the first stage, Dolphin generates a sequence of layout elements in reading order. These heterogeneous elements, serving as anchors and coupled with task-specific prompts, are fed back to Dolphin for parallel content parsing in the second stage. To train Dolphin, we construct a large-scale dataset of over 30 million samples, covering multi-granularity parsing tasks. Through comprehensive evaluations on both prevalent benchmarks and self-constructed ones, Dolphin achieves state-of-the-art performance across diverse page-level and element-level settings, while ensuring superior efficiency through its lightweight architecture and parallel parsing mechanism. The code and pre-trained models are publicly available atGitHub - bytedance/Dolphin: The official repo for “Dolphin: Document Image Parsing via Heterogeneous Anchor Prompting”, ACL, 2025.논문 링크arXiv.orgDolphin: Document Image Parsing via Heterogeneous Anchor PromptingDocument image parsing is challenging due to its complexly intertwined elements such as text paragraphs, figures, formulas, and tables. Current approaches either assemble specialized expert models or directly generate page-level content...더 읽어보기github.comGitHub - bytedance/Dolphin: The official repo for “Dolphin: Document Image...The official repo for “Dolphin: Document Image Parsing via Heterogeneous Anchor Prompting”, ACL, 2025.github.comGitHub - bytedance/Dolphin: The official repo for “Dolphin: Document Image...The official repo for “Dolphin: Document Image Parsing via Heterogeneous Anchor Prompting”, ACL, 2025.huggingface.coByteDance/Dolphin · Hugging FaceWe’re on a journey to advance and democratize artificial intelligence through open source and open science.Dolphin: ByteDance가 공개한, 이종간 앵커 프롬프트 기반 문서 이미지 파싱 모델읽을거리&정보공유[Dophin: ByteDance가 공개한, 이종간 앵커 프롬프트 기반 문서 이미지 파싱 모델]Dophin 모델 소개\n문서 이미지를 텍스트, 수식, 표, 그림 등 다양한 요소로 나누고 이를 자동으로 추출하는 기술은 여전히 어렵고 복잡한 문제입니다. ByteDance가 발표한 Dolphin(Document Image Parsing via Heterogeneous Anchor Prompting)은 이를 해결하기 위해 ‘분석 후 파싱(analyze-then-parse)’ 방식을 제안하며, 학계와 산업계의 최신 모델들과 비교해 속도와 성능 모두에서 우수한 결과를 보여주고 있습니다. \n[Dolphin] \nDolphin은 문서 이미지에서 복잡하게 얽힌 구성 요소를 인식하고 이를 구조화된 형태로 파싱하는 데 초점을 맞춘 모델입니다. 기존 방식은 보통 OCR 기반 파이프라인을 사용하거나 VLM(비전-언어 모델) 기반으로 전체 페이지를 생성해내는 방식이었지만, 이들은 효율성과 레이아웃 보존 측…파이토치 한국 사용자 모임이 정리한 이 글이 유용하셨나요?회원으로 가입하시면 주요 글들을 이메일로 보내드립니다! (기본은 Weekly지만Daily로 변경도 가능합니다.)아래쪽에 좋아요를 눌러주시면 뉴스 발행에 힘이 됩니다~",
        "summary": "PyTorchKR이 2025년 6월 23일부터 29일까지 발표된 AI/ML 논문들을 요약했습니다.  주요 내용은 멀티에이전트 협업 및 경험 축적을 통한 추론 능력 향상, 시각-언어 결합 멀티모달 AI의 발전, 그리고 장기적 데이터 효율적 처리를 위한 메모리 관리 및 토큰 선택 기법 연구입니다.  특히, Xolver와 MEM1, Visionary-R1, Griffon-R, FlexSelect 등의 모델이 각 분야에서 주목할 만한 성능 향상을 보였습니다.\n"
    },
    {
        "title": "Context: macOS에서 MCP 서버 디버깅을 위한 네이티브 클라이언트",
        "url": "https://discuss.pytorch.kr/t/context-macos-mcp/7206",
        "source": "pytorch_kr",
        "body": "Context: macOS에서 MCP 서버 디버깅을 위한 네이티브 클라이언트1486×380 30.3 KBContext 소개최근 인공지능 및 자연어 처리 분야에서 서버와 클라이언트 간의 커뮤니케이션 프로토콜이 점점 더 정교해지고 있습니다. 특히 MCP(Model Context Protocol)는 개발자들이 대형 언어 모델 서버와 상호작용하고 이를 디버깅하는 데에 중요한 역할을 합니다. 이 프로토콜은 모델 서버가 툴, 리소스, 로그 등의 기능을 외부에서 통합적으로 제어할 수 있도록 설계된 표준이며, 여러 신생 플랫폼과 IDE에서도 점점 더 많이 채택되고 있는 추세입니다.image1028×745 58.2 KB이러한 MCP 서버와의 상호작용을 보다 직관적이고 시각적으로 제공하는 macOS 전용 클라이언트가 바로 ‘Context’입니다. Swift와 SwiftUI로 개발된 이 애플리케이션은 개발자들이 MCP 서버와 실시간으로 소통하고, 툴 실행, 로그 분석, 리소스 미리 보기 등 다양한 기능을 간편하게 활용할 수 있도록 돕습니다. 무엇보다도, 서버 개발 중 실시간 디버깅에 필요한 다양한 시각화 요소를 갖추고 있어, 복잡한 설정이나 명령어 없이 GUI 기반으로 문제를 빠르게 파악할 수 있다는 점이 큰 장점입니다.특히 Cursor, Claude Code, Windsurf, VS Code 같은 툴에서 자동으로 MCP 서버 정보를 가져올 수 있어, 다양한 워크플로우에 쉽게 통합 가능합니다. 더불어 JSON Schema 기반 자동 UI 생성, 동적 프롬프트 생성, OAuth 인증 지원, HTTP+SSE를 포함한 다양한 통신 프로토콜 대응 등도 ‘Context’를 유용하게 만들어주는 요소입니다.MCP의 최신 사양(예: 2025-03-26)에 기반하여 개발되었으며, 새로운 사양(2025-06-18)에 대한 지원도 계속 진행 중입니다.기존에는 MCP 서버와의 인터랙션을 위해 주로 CLI 기반 도구나 브라우저 기반 클라이언트를 사용하는 경우가 많았습니다. 하지만 이들은 직관성이 떨어지고, 동시에 여러 서버를 연결하거나 리소스를 시각화하는 데에는 제약이 많았습니다. 반면 ‘Context’는 다음과 같은 차별성을 가집니다:네이티브 macOS 앱으로 제작되어 macOS 환경에 최적화된 UI/UX 제공SwiftUI 기반 인터페이스로 반응성이 뛰어나며 유지보수가 쉬움실시간 로그 스트리밍 및 필터링 기능은 CLI 기반 도구보다 디버깅에 훨씬 효과적QuickLook 미리보기및리소스 자동 하이라이팅기능으로 자료 확인이 용이자동 서버 감지 기능은 기존 도구들에서 보기 어려운 자동화 기능주요 기능MCP 디버깅을 위한 GUI 인터페이스: Context는 복잡한 커맨드 없이도 MCP 서버와 상호작용할 수 있는 시각적 인터페이스를 제공합니다. 툴 실행, 로그 확인, 리소스 미리 보기 등을 버튼 클릭으로 손쉽게 수행할 수 있습니다.다중 서버 연결 및 자동 감지: Cursor, Claude Desktop, Windsurf 등에서 실행 중인 MCP 서버를 자동으로 감지하고 연결할 수 있습니다. 덕분에 설정 시간을 줄이고 다양한 환경에서 빠르게 실험할 수 있습니다.JSON Schema 기반 UI 생성: 툴 호출 인터페이스는 MCP 서버에서 제공하는 JSON Schema를 기반으로 자동 생성되며, 동적 프롬프트 템플릿을 적용하여 사용자 편의성을 극대화합니다.실시간 로그 분석: 로그는 실시간으로 스트리밍되며, 필터링 및 구조적 뷰를 통해 원하는 정보를 빠르게 찾을 수 있습니다. 이는 모델 서버의 상태나 요청 흐름을 실시간으로 추적하는 데 매우 유용합니다.MCP 사양 지원 현황: 2025년 3월 버전의 MCP 사양을 완벽하게 지원하며, 최신 버전인 2025년 6월 사양은 개발 진행 중입니다. 인증은 OAuth 2.0 및 2.1 사양을 지원하며, 다양한 Transport 방식도 폭넓게 대응합니다. 주요 지원 기능은 다음과 같습니다:지원 기능상태stdio / HTTP+SSE / Streamable HTTP지원OAuth 인증 및 메타데이터 탐색지원툴 / 리소스 / 프롬프트 / 로그지원Roots / Sampling / Completion 등 고급 기능미지원 (예정)Context의 최신 릴리스는 GitHubReleases 페이지에서 다운로드할 수 있으며, macOS 15.0 이상이 요구됩니다.개인정보 및 텔레메트리: Context는 Sentry를 이용해 충돌 보고와 피드백 수집을 진행합니다. 개인 정보 보호가 필요한 경우SENTRY_DISABLED플래그를 추가하여 컴파일 시 텔레메트리를 비활성화할 수 있습니다.라이선스Context 프로젝트는MIT 라이선스로 공개 및 배포되고 있습니다. 상업적 사용에 제한은 없으며, 저작권 고지와 라이선스 명시만 유지하면 자유롭게 사용할 수 있습니다.Context 프로젝트 GitHub 저장소github.comGitHub - indragiek/Context: Native macOS client for Model Context Protocol...Native macOS client for Model Context Protocol (MCP)이 글은 GPT 모델로 정리한 글을 바탕으로 한 것으로, 원문의 내용 또는 의도와 다르게 정리된 내용이 있을 수 있습니다. 관심있는 내용이시라면 원문도 함께 참고해주세요! 읽으시면서 어색하거나 잘못된 내용을 발견하시면 덧글로 알려주시기를 부탁드립니다.파이토치 한국 사용자 모임이 정리한 이 글이 유용하셨나요?회원으로 가입하시면 주요 글들을 이메일로 보내드립니다! (기본은 Weekly지만Daily로 변경도 가능합니다.)아래쪽에 좋아요를 눌러주시면 새로운 소식들을 정리하고 공유하는데 힘이 됩니다~",
        "summary": "macOS용 네이티브 MCP(Model Context Protocol) 클라이언트인 'Context'는  대형 언어 모델 서버 디버깅을 위한 직관적인 GUI를 제공합니다.  SwiftUI로 개발되어 실시간 로그 스트리밍, 리소스 미리보기, 다중 서버 연결 등의 기능을 통해 효율적인 디버깅 환경을 구축하며,  다양한 개발 툴과의 통합을 지원합니다.  JSON Schema 기반 자동 UI 생성 및 OAuth 인증 지원 등을 통해 사용 편의성을 높였습니다.\n"
    },
    {
        "title": "NviWatch: NVIDIA GPU 상태를 터미널에서 실시간으로 모니터링하는 Rust 기반 TUI 도구",
        "url": "https://discuss.pytorch.kr/t/nviwatch-nvidia-gpu-rust-tui/7197",
        "source": "pytorch_kr",
        "body": "NviWatch: NVIDIA GPU 상태를 터미널에서 실시간으로 모니터링하는 Rust 기반 TUI 도구1548×352 23.4 KBNviWatch 소개최근 몇 년 간 머신러닝과 데이터 과학의 확산으로 인해 NVIDIA GPU를 사용하는 환경이 급격히 증가했습니다. 이에 따라 GPU 자원의 활용률을 실시간으로 확인하고, 이상 징후를 신속히 파악하는 모니터링 도구의 중요성도 더욱 커지고 있습니다. 이러한 필요에 대응하기 위해 다양한 도구들이 등장했지만, 대부분은 무겁거나 GUI에 의존하여 서버 환경에서 쓰기 어렵다는 단점이 있습니다.NviWatch는 이러한 문제점을 해결하기 위해 등장한 경량의 터미널 기반 사용자 인터페이스(TUI) 프로그램입니다. Rust 언어로 개발되었으며, NVIDIA GPU의 온도, 사용률, 메모리 사용량, 전력 소비 등을 실시간으로 확인할 수 있습니다. 또한, InfluxDB와 연동하여 장기적인 GPU 모니터링도 가능하다는 특징을 가집니다.터미널에서 실행되며 직관적인 키 바인딩으로 손쉽게 조작할 수 있고, 다양한 시각화 모드를 지원해 여러 GPU 시스템에서도 유용하게 사용할 수 있습니다. 무엇보다도 매우 낮은 CPU 및 메모리 사용량 덕분에 서버에 부하를 주지 않는 것이 큰 장점입니다.NviWatch는 nvtop, nvitop, gpustat과 같은 기존의 인기 있는 GPU 모니터링 툴들과 성능 비교가 진행되었습니다:CPU 사용률: NviWatch는 평균 0.28%로, gpustat(3.47%)이나 nvitop(0.88%)에 비해 훨씬 낮습니다. nvtop과는 유사하지만 최대 사용률은 더 안정적입니다.메모리 사용량: 평균 18MB로 nvitop(41MB), gpustat(33MB)에 비해 가볍고 nvtop보다도 소폭 낮습니다.패키지 크기: 1.98MB로 크기면에서는 nvitop(4.1MB)보다 가볍지만, nvtop은 매우 작은 106KB입니다.즉, NviWatch는 성능과 리소스 효율성 면에서 매우 경쟁력 있는 도구라 할 수 있습니다.NviWatch의 주요 기능실시간 GPU 상태 모니터링GPU 온도, 사용률, 메모리 사용량, 전력 소비를 실시간으로 확인할 수 있습니다.데이터는 터미널 화면에 시각적으로 표현되며, 바 그래프 또는 탭 형태로 전환 가능합니다.프로세스 관리GPU를 점유하고 있는 프로세스 목록을 확인하고, 원클릭으로 종료할 수 있는 기능도 포함되어 있습니다.다양한 시각화 모드기본 모드: 전체 GPU 상태를 단일 화면에 표시바 차트 모드: 각 지표를 바 형태로 시각화탭 모드: 멀티 GPU 환경에서 GPU 별로 탭으로 구분하여 표시InfluxDB 통합수집된 GPU 지표를 InfluxDB로 전송하여 장기 저장 및 Grafana 같은 도구로 시각화 가능scripts/setup_influxdb.sh 스크립트를 통해 InfluxDB 설치 및 대시보드 자동 구성 지원InfluxDB 연동 설정InfluxDB를 설치하고 NviWatch와 연동하여 실시간 GPU 데이터를 저장 및 시각화하는 방법은 다음과 같습니다:스크립트를 실행하여 InfluxDB 설치:chmod +x scripts/setup_influxdb.sh\n./scripts/setup_influxdb.sh관리 토큰을 발급:influx auth listNviWatch 실행 시 다음 옵션을 통해 연동:./nviwatch \\\n  --influx-url \"http://localhost:8086\" \\\n  --influx-org \"my-org\" \\\n  --influx-bucket \"gpu-metrics\" \\\n  --influx-token \"your-admin-token-here\"NviWatch 설치 및 실행 방법사전 요구사항NVIDIA Management Library(NVML)가 설치되어 있어야 합니다.Rust 및 Cargo 설치 필요(소스 빌드 또는 Cargo 설치 방식 시)방법 1: 바이너리 다운로드GitHub Release 페이지에서 Linux용 바이너리 다운로드 후 실행 권한 부여 및 실행:chmod +x nviwatch\n./nviwatch방법 2: Cargo 설치cargo install nviwatch방법 3: 소스 코드 빌드git clone https://github.com/msminhas93/nviwatch.git\ncd nviwatch\ncargo build --release\n./target/release/nviwatch단축키 및 사용 방법q: 종료↑/↓: 프로세스 탐색←/→: GPU 탭 전환x: 프로세스 종료d/t/b: 기본/탭/바 보기 모드 전환명령어 옵션도 다양하며, InfluxDB 연동 설정도 커맨드라인 인자로 간단하게 적용 가능합니다.라이선스NviWatch 프로젝트는GNU General Public License v3.0로 공개 및 배포되고 있습니다. 상업적 사용은 가능하지만, 소스 코드를 공개하거나 동일 라이선스로 배포해야 합니다.NviWatch 프로젝트 GitHub 저장소github.comGitHub - msminhas93/nviwatch: NviWatch: A blazingly fast rust based TUI for...NviWatch: A blazingly fast rust based TUI for managing and monitoring NVIDIA GPU processes이 글은 GPT 모델로 정리한 글을 바탕으로 한 것으로, 원문의 내용 또는 의도와 다르게 정리된 내용이 있을 수 있습니다. 관심있는 내용이시라면 원문도 함께 참고해주세요! 읽으시면서 어색하거나 잘못된 내용을 발견하시면 덧글로 알려주시기를 부탁드립니다.파이토치 한국 사용자 모임이 정리한 이 글이 유용하셨나요?회원으로 가입하시면 주요 글들을 이메일로 보내드립니다! (기본은 Weekly지만Daily로 변경도 가능합니다.)아래쪽에 좋아요를 눌러주시면 새로운 소식들을 정리하고 공유하는데 힘이 됩니다~",
        "summary": "NviWatch는 Rust 기반의 경량 TUI 도구로, NVIDIA GPU의 온도, 사용률 등을 실시간으로 모니터링합니다.  기존 도구들보다 훨씬 낮은 CPU 및 메모리 사용량을 자랑하며, InfluxDB 연동을 통해 장기적인 모니터링 및 데이터 시각화도 지원합니다.  터미널에서 직관적인 키 바인딩으로 조작이 가능하고, 다양한 시각화 모드와 프로세스 관리 기능을 제공합니다.\n"
    },
    {
        "title": "Firestarter - 웹사이트 콘텐츠를 바탕으로 AI Chatbot을 만들어주는 오픈소스 프로젝트",
        "url": "https://discuss.pytorch.kr/t/firestarter-ai-chatbot/7194",
        "source": "pytorch_kr",
        "body": "Firestarter 소개Firestarter는 웹사이트에 대한 이해를 바탕으로 즉시 활용 가능한 AI 챗봇을 생성해주는 오픈소스 프로젝트입니다. 이 툴은 URL만 입력하면 웹사이트의 콘텐츠를 자동으로 크롤링하고, 의미 기반 검색이 가능한 벡터 인덱스로 저장한 뒤, OpenAI 호환 인터페이스를 제공하는 챗봇으로 변환해줍니다. 개발자에게는 이는 곧 자신만의 RAG 기반 챗봇을 몇 분 안에 손쉽게 구축할 수 있는 기회를 의미합니다.RAG(Retrieval-Augmented Generation)는 기존의 LLM이 제공하지 못했던 외부 지식 활용의 가능성을 열어주는 접근 방식입니다. Firestarter는 Firecrawl, Upstash Search, Vercel AI SDK, OpenAI 등 최신 기술 스택을 기반으로 작동하며, 특히 개발자가 배포와 확장에 유리한 형태로 설계되어 있습니다. 이 프로젝트는 복잡한 프롬프트 엔지니어링과 인프라 세팅 없이도 AI 챗봇을 구축하고, 이를 API 형태로 다른 애플리케이션에서 사용할 수 있도록 구성되어 있습니다.Firestarter의 장점은 단순한 챗봇 생성 도구를 넘어, 웹사이트 자체를 쿼리 가능한 데이터 소스로 활용할 수 있다는 점입니다. 예를 들어 기술 문서 페이지나 블로그를 대상으로 챗봇을 생성하면, 그 사이트의 내용에 기반해 정확하고 맥락 있는 응답을 생성해줄 수 있습니다. 이는 개발자 문서, 고객 지원, FAQ 시스템 등에 매우 유용하게 활용될 수 있습니다.또한 오픈소스로 제공되어 직접 커스터마이징하거나 확장할 수 있으며, 다양한 LLM 공급자를 지원합니다. GPT-4o(OpenAI), Claude 3.5(Anthropic), Groq 등 다양한 모델을 환경변수 설정만으로 쉽게 교체할 수 있는 점도 매력적인 기능 중 하나입니다.Firestarter는 단일 기능 챗봇 생성기를 넘어서 완전한 RAG 파이프라인을 포함한 플랫폼입니다. 비슷한 프로젝트로는DocsGPT,LangChain,LlamaIndex등이 있지만, Firestarter는 다음과 같은 차별점을 가집니다:즉시 사용 가능: 복잡한 파이프라인 설정 없이 URL 입력만으로 작동.OpenAI 호환 API 제공: 생성된 챗봇을 OpenAI API 클라이언트와 동일한 방식으로 호출 가능.프론트엔드 포함: Vercel AI SDK 기반 스트리밍 응답 인터페이스 제공.다양한 LLM 지원: OpenAI, Anthropic, Groq 등을 유연하게 지원.강력한 인덱싱: Firecrawl + Upstash Search 조합으로 정확하고 빠른 검색 성능 확보.Firestarter의 작동 원리웹사이트 인덱싱Firestarter는 사용자가 URL을 입력하면 백엔드에서 다음 단계를 거쳐 데이터를 수집합니다.URL 제출:/api/firestarter/create엔드포인트를 통해 프론트엔드에서 URL을 제출합니다.웹 크롤링: Firecrawl API를 이용해 입력된 웹사이트의 페이지들을 Markdown 형식으로 수집합니다.벡터 인덱싱: 수집된 Markdown 콘텐츠는 Upstash Search에 저장되며, 자동으로 청크 단위로 나뉘고 벡터로 임베딩됩니다.네임스페이스 생성: 각 웹사이트는 고유한 네임스페이스를 부여받아 챗봇 간 데이터가 격리됩니다.메타데이터 저장: Redis나 브라우저 저장소를 통해 URL, 아이콘, 제목 등의 정보가 저장됩니다.질문 응답 (RAG 파이프라인)생성된 챗봇은 다음과 같은 방식으로 질문에 응답합니다.질문 입력: 사용자가 질문을 하면/api/firestarter/query엔드포인트로 전달됩니다.의미 기반 검색: Upstash Search에서 네임스페이스 내 의미적으로 가장 유사한 문서 청크를 찾습니다.프롬프트 생성: 선택된 청크와 질문을 바탕으로 시스템 프롬프트를 생성하고 LLM에 전달합니다.스트리밍 응답: Vercel AI SDK를 통해 생성된 응답을 실시간으로 프론트엔드에 전송합니다.OpenAI 호환 APIFirestarter는 생성된 각 챗봇에 대해 OpenAI와 호환되는 API 엔드포인트를 제공합니다. 사용자는 다음 방식으로 API를 사용할 수 있습니다:import OpenAI from 'openai';\n\nconst firestarter = new OpenAI({\n  apiKey: 'any_string', // 인증은 Firestarter 서버에서 처리\n  baseURL: 'https://your-firestarter-deployment.vercel.app/api/v1/chat/completions'\n});\n\nconst completion = await firestarter.chat.completions.create({\n  model: 'firecrawl-example-com-12345',\n  messages: [{ role: 'user', content: 'What is Firecrawl?' }],\n});구성 및 설정환경 변수 설정다음 API 키가 필요합니다:Firecrawl:https://www.firecrawl.dev/app/api-keysUpstash:https://console.upstash.comOpenAI:https://platform.openai.com/api-keys.env.local예시:FIRECRAWL_API_KEY=your_firecrawl_key\nUPSTASH_SEARCH_REST_URL=your_upstash_search_url\nUPSTASH_SEARCH_REST_TOKEN=your_upstash_search_token\nOPENAI_API_KEY=your_openai_key크롤링 제한 변경firestarter.config.ts파일에서 다음처럼 설정을 조정할 수 있습니다:crawling: {\n  defaultLimit: 10,\n  maxLimit: 100,\n  minLimit: 10,\n  limitOptions: [10, 25, 50, 100],\n}LLM 우선순위 조정기본 순서는OpenAI → Anthropic → Groq입니다..env.local에서 사용하고자 하는 LLM의 키만 설정하면 해당 순서에 따라 자동 선택됩니다. 원하는 우선순위를 적용하고 싶다면firestarter.config.ts의getAIModel함수를 수정하면 됩니다.Firestarter 프로젝트 GitHub 저장소github.comGitHub - mendableai/firestarter:  🔥 Instantly create AI chatbots for any website...🔥 Instantly create AI chatbots for any website with RAG-powered search, streaming responses, and OpenAI-compatible API endpoints이 글은 GPT 모델로 정리한 글을 바탕으로 한 것으로, 원문의 내용 또는 의도와 다르게 정리된 내용이 있을 수 있습니다. 관심있는 내용이시라면 원문도 함께 참고해주세요! 읽으시면서 어색하거나 잘못된 내용을 발견하시면 덧글로 알려주시기를 부탁드립니다.파이토치 한국 사용자 모임이 정리한 이 글이 유용하셨나요?회원으로 가입하시면 주요 글들을 이메일로 보내드립니다! (기본은 Weekly지만Daily로 변경도 가능합니다.)아래쪽에 좋아요를 눌러주시면 새로운 소식들을 정리하고 공유하는데 힘이 됩니다~",
        "summary": "Firestarter는 웹사이트 URL만 입력하면 웹사이트 내용을 기반으로 AI 챗봇을 생성하는 오픈소스 프로젝트입니다.  OpenAI 호환 API를 제공하며,  Firecrawl, Upstash Search 등을 활용해 빠르고 정확한 검색과 스트리밍 응답을 지원하고 다양한 LLM을 지원하는 것이 특징입니다.  복잡한 설정 없이 쉽게 사용 가능하며,  개발자 문서, 고객 지원 등 다양한 분야에 활용될 수 있습니다.\n"
    },
    {
        "title": "Claude Code Router: 다양한 LLM 환경에서 Claude Code를 효율적으로 사용하는 라우팅 도구",
        "url": "https://discuss.pytorch.kr/t/claude-code-router-llm-claude-code/7202",
        "source": "pytorch_kr",
        "body": "Claude Code Router: 다양한 LLM 환경에서 Claude Code를 효율적으로 사용하는 라우팅 도구1200×344 24.8 KBClaude Code Router 소개대규모 언어 모델(LLM)의 등장과 함께 다양한 플랫폼과 API가 범람하면서, 하나의 환경에서 여러 모델을 유연하게 활용할 수 있는 기반 시스템에 대한 수요가 높아졌습니다. 특히 Anthropic의 Claude Code는 고도화된 코드 기반 작업을 지원하는 도구로 각광받고 있지만, 특정 API나 모델에 종속되어 있으면 비용 문제나 기능 제약에 부딪힐 수 있습니다. 이러한 문제를 해결하고자 탄생한 것이 바로 Claude Code Router입니다.image1796×1414 156 KBClaude Code Router는 다양한 LLM 제공업체(OpenAI, DeepSeek, Anthropic, Google 등)의 API를 기반으로, 사용자가 직접 라우팅 전략을 정의해 어떤 요청을 어떤 모델에 보낼지 세밀하게 설정할 수 있는 도구입니다. 예컨대, 배경 처리에는 경량 모델을, 고도 추론에는 DeepSeek Reasoner를, 긴 컨텍스트 처리에는 Gemini 2.5 Pro와 같은 모델을 사용하도록 분기할 수 있습니다. 이를 통해 성능과 비용을 모두 최적화하는 전략적인 LLM 운용이 가능해집니다.또한 이 프로젝트는 단순히 라우터 기능에 그치지 않고, 플러그인 지원, GitHub Actions 통합, 다양한 명령어 확장 기능 등을 제공하며, 실제 코드 환경에서 Claude Code를 업무 자동화 도구로 활용하려는 개발자들에게 실질적인 도움이 되는 구성을 갖추고 있습니다. 특히 GitHub Actions와 연계해 특정 시간대에 작업을 예약 실행하는 기능은 비용 효율적인 대규모 배치 처리 전략에 유용하게 쓰일 수 있습니다.Claude Code Router는 Claude Code를 기반으로 여러 LLM API를 유연하게 라우팅하여 사용할 수 있게 도와주는 커맨드라인 기반의 도구입니다. 기본적으로는@anthropic-ai/claude-code를 먼저 설치한 뒤,@musistudio/claude-code-router를 글로벌로 설치해 함께 사용하게 됩니다. 설정은 사용자의 홈 디렉터리 하위에 존재하는~/.claude-code-router/config.json파일을 통해 이루어지며, API 키와 모델 목록, 라우팅 전략 등을 자유롭게 정의할 수 있습니다.Claude Code Router의 라우팅 전략 구성 방식라우팅 설정의 핵심은 background, think, longContext 세 가지 시나리오에 대해 어떤 모델을 사용할지 지정하는 방식입니다.background: 배경 처리 전용 모델로, 고성능이 요구되지 않아 경량 모델인 Qwen-coder 2.5:7b 또는 3b와 같은 모델을 사용합니다. 로컬 Ollama로 구동 가능하여 비용 절감 효과가 큽니다.think: 복잡한 추론이 필요한 상황에서 사용되며, DeepSeek Reasoner가 주요 모델로 쓰입니다. 현재는 예산 조절 기능이 구현되어 있지 않지만, Plan Mode와 같이 고차원적인 작업에 활용됩니다.longContext: 입력 토큰 수가 많은 경우를 위한 전략으로, Gemini 2.5 Pro와 같은 긴 컨텍스트를 지원하는 모델을 사용합니다.또한/model provider,model명령어를 사용하면 실행 중에 동적으로 모델을 변경할 수 있습니다. 예를 들어, OpenRouter에서 제공하는 Claude-3.5 Sonnet 모델을 사용하고 싶다면/model openrouter,anthropic/claude-3.5-sonnet을 입력하면 됩니다.Cluade Code Router의 주요 특징플러그인 시스템Claude Code Router는 미들웨어 구조로 플러그인을 설치하고 활성화할 수 있습니다. 플러그인은~/.claude-code-router/plugins/디렉터리에 배치하며,config.json의usePlugins옵션에 이름을 추가해 사용할 수 있습니다. 현재 제공되는 플러그인은 다음과 같습니다:notebook-tools-filter: 주피터 노트북 관련 도구 호출을 필터링합니다.toolcall-improvement: 툴 사용 능력이 떨어지는 모델(예: DeepSeek-V3)의 응답 품질을 개선하는 시스템 프롬프트를 추가합니다.GitHub Actions와의 통합Claude Code Router는 GitHub Actions를 통해 자동화된 워크플로우를 구성할 수 있습니다.@claude가 포함된 이슈나 PR 코멘트 발생 시 특정 모델을 구동시켜 응답하도록 설정할 수 있으며, 이때 설정 파일에 Router 구성과 API 키, 실행 명령어를 포함시켜야 합니다.특히 DeepSeek API는 특정 시간대(중국 기준 새벽)에 비용이 절반 이하로 떨어지기 때문에, 작업을 예약 실행해 비용을 절감하는 전략도 고려할 수 있습니다.기타 팁 및 유용한 정보DeepSeek API를 사용할 경우, 공식 API는 최대 64K 컨텍스트 제한이 있으며, ByteDance API를 사용하면 128K까지 확장 가능합니다. KV 캐시도 지원되므로 복잡한 연산에 유리합니다. 실제 테스트에서 Claude-4보다 DeepSeek 모델이 낮은 비용 대비 더 안정적인 결과를 내는 경우도 있었으며, 이는 컨텍스트 활용 전략이 모델 성능에 큰 영향을 준다는 점을 시사합니다.라이선스Claude Code Router 프로젝트는MIT 라이선스로 공개되어 있으며, 상업적 이용 및 수정에 제약이 없습니다.Claude Code Router 프로젝트 GitHub 저장소github.comGitHub - musistudio/claude-code-router: Use Claude Code as the foundation for coding...Use Claude Code as the foundation for coding infrastructure, allowing you to decide how to interact with the model while enjoying updates from Anthropic.이 글은 GPT 모델로 정리한 글을 바탕으로 한 것으로, 원문의 내용 또는 의도와 다르게 정리된 내용이 있을 수 있습니다. 관심있는 내용이시라면 원문도 함께 참고해주세요! 읽으시면서 어색하거나 잘못된 내용을 발견하시면 덧글로 알려주시기를 부탁드립니다.파이토치 한국 사용자 모임이 정리한 이 글이 유용하셨나요?회원으로 가입하시면 주요 글들을 이메일로 보내드립니다! (기본은 Weekly지만Daily로 변경도 가능합니다.)아래쪽에 좋아요를 눌러주시면 새로운 소식들을 정리하고 공유하는데 힘이 됩니다~",
        "summary": "Claude Code Router는 다양한 LLM API(OpenAI, Anthropic, Google 등)를 활용하여 Claude Code를 효율적으로 사용할 수 있도록 설계된 커맨드라인 도구입니다.  사용자는 요청에 따라 최적의 모델을 선택하는 라우팅 전략을 직접 정의하여 비용과 성능을 최적화할 수 있으며, 플러그인 지원, GitHub Actions 통합 등 다양한 기능을 제공합니다.  GitHub Actions 연동을 통해 예약 실행 기능을 활용하면 비용 효율적인 대규모 배치 처리가 가능합니다.\n"
    },
    {
        "title": "MCPJam Inspector: MCP Server의 시각적 디버깅을 위한 Web UI 기반 도구",
        "url": "https://discuss.pytorch.kr/t/mcpjam-inspector-mcp-server-web-ui/7215",
        "source": "pytorch_kr",
        "body": "MCPJam Inspector: MCP Server의 시각적 디버깅을 위한 Web UI 기반 도구1470×810 133 KBMCPJam Inspector 소개MCPJam Inspector는 Model Context Protocol(MCP) 서버 개발자들을 위한 시각적 디버깅 툴로, 웹 UI 기반으로 서버 테스트, 툴 호출, 로깅, AI 도구 연동 등을 지원합니다. 이 도구는modelcontextprotocol/inspector 프로젝트의 포크 버전이며, MCPJam 팀이 “더 빠르게, 더 많은 기능을” 목표로 기능을 확장해왔습니다.image1028×508 34.4 KBMCP 개발자라면 HTTP 클라이언트로 요청 하나씩 보내며 디버깅하는 과정을 겪어봤을 것입니다. MCPJam Inspector를 쓰면 클릭 몇 번으로 테스트 서버 띄우고, 툴 호출 테스트, 로그 확인, 심지어 LLM과 상호작용해 AI 도구 테스트까지 한 곳에서 가능해집니다. 특히 AI 파라미터 완성과 LLM 모델과의 직접 연동 기능은 차별점입니다 .MCPJam Inspector의 주요 기능image2534×1118 216 KB다양한 통신 방식 지원: STDIO, SSE, Streamable HTTP 등 거의 모든 MCP 서버 환경에서 연결 가능Tool 실행 및 로깅 강화: 입력 파라미터를 실시간으로 입력하고 호출 후 응답을 실시간 로그로 확인LLM 도구 테스트: 실제 LLM(예: Claude 등)과 연결해 MCP 툴 상호작용 테스트 가능요청 저장 & 서버 관리: 요청 콜렉션, 다중 서버 연결, 저장된 연결 설정 기능 포함QOL 개선: AI 기반 파라미터 자동완성, 다크모드 스타일 개선, INFO 로그 색상 조정 등설치 & 실행 가이드CLI 기반 방식 (권장)npx @mcpjam/inspector@latest기본적으로http://localhost:6274에서 웹 UI가 자동으로 실행됩니다 .Docker를 사용한 실행 방식# Docker Image를 가져옵니다\ndocker pull mcpjam/mcp-inspector:main  \n# 가져온 Docker Image로 Container를 실행합니다\ndocker run --rm -p 6274:6274 -p 6277:6277 mcpjam/mcp-inspector:main웹 UI는http://127.0.0.1:6274에서 접근 가능합니다 .서버 연결 예시기본 사용:npx @mcpjam/inspector node build/index.js커맨드라인 인자 포함:npx @mcpjam/inspector node server.js --port 3000 --debug설정 파일로 다중 서버 연결:npx @mcpjam/inspector --config ./my-config.json아래는 설정 파일 예시입니다:{\n  \"mcpServers\": {\n    \"my-server\": {\n      \"command\": \"node\",\n      \"args\": [\"build/index.js\"],\n      \"env\": {\n        \"KEY\": \"value\"\n      }\n    },\n    \"py-server\": {\n      \"command\": \"python\",\n      \"args\": [\"-m\", \"my_mcp_server\"],\n      \"env\": {\n        \"PYTHONPATH\": \"./src\"\n      }\n    }\n  }\n}\n```라이선스MCPJam의 Inspector는Apache License 2.0으로 배포되며, 상업적/비상업적 사용 모두 자유로운 오픈소스입니다MCPJam Inspector 홈페이지MCPJam InspectorMCPJam Inspector - Test and Debug MCP Servers with AIMCPJam Inspector is a developer tool for testing and debugging Model Context Protocol servers with AI assistance.MCPJam Inspector 프로젝트 GitHub 저장소github.comGitHub - MCPJam/inspector: Postman for MCPs - A tool for testing and...Postman for MCPs - A tool for testing and debugging MCPs이 글은 GPT 모델로 정리한 글을 바탕으로 한 것으로, 원문의 내용 또는 의도와 다르게 정리된 내용이 있을 수 있습니다. 관심있는 내용이시라면 원문도 함께 참고해주세요! 읽으시면서 어색하거나 잘못된 내용을 발견하시면 덧글로 알려주시기를 부탁드립니다.파이토치 한국 사용자 모임이 정리한 이 글이 유용하셨나요?회원으로 가입하시면 주요 글들을 이메일로 보내드립니다! (기본은 Weekly지만Daily로 변경도 가능합니다.)아래쪽에 좋아요를 눌러주시면 새로운 소식들을 정리하고 공유하는데 힘이 됩니다~",
        "summary": "MCPJam Inspector는 웹 UI 기반의 시각적 디버깅 도구로, Model Context Protocol(MCP) 서버 개발자가 서버 테스트, 툴 호출, 로깅, AI 도구 연동 등을 편리하게 수행할 수 있도록 지원합니다.  다양한 통신 방식과 LLM 연동을 지원하며, AI 기반 파라미터 자동완성 등 편의 기능을 제공하여 효율적인 디버깅 환경을 제공합니다.  CLI 또는 Docker를 통해 설치 가능하며, Apache License 2.0으로 배포되는 오픈소스 프로젝트입니다.\n"
    },
    {
        "title": "[Obsidian] 플러그인_추천_및_10개월_사용후기.md",
        "url": "https://dnai-deny.tistory.com/116",
        "source": "raindrop",
        "body": "728x90모 지인이 obsidian이 어렵다고 쓰는 법을 노션(?)에 정리해달라는 말을 들어서 간단하게 적어보는 obsidian 1년 사용기 및 방법이다. 이전에 써서 올린 적이 있던 notion과의 비교글, obsidian 플러그인 및 git 연동법에 이어 세 번째 글이다. 아마 이 글 이후로 다시 obsidian에 대해 다루지는 않을 듯 하다.[Obsidian] Notion vs Obsidian, 내가 Obsidian으로 이사한 이유2~3주 전이었나? 업무시간 중간에 Notion 서버에 잠시간 장애가 발생했던 적이 있다. 나는 내 기억력을 안 믿는 편이라 해야할 업무부터 일하면서 리서치한 내용 등을 노션에 다 기록해두고 쓰고dnai-deny.tistory.com[Obsidian] 커뮤니티 플러그인 추천 및 Git을 활용한 연동법지난 포스팅에서는 Obsidian과 Notion을 비교하는 내용을 다뤘었는데, 이번 포스팅에서는 어차피 옵시디언으로 넘어온 거! 기깔나게 써봅세! 하는 마음가짐으로 커뮤니티 플러그인 소개를 하도록dnai-deny.tistory.com1. Obsidian의 구조obsidian은 노션보다 더 엄격한 마크다운 문법을 따른다. 이게 아주 편할 때도 있고 불편할 때도 있는데, 사실 적응만 하고 나면 노션보다 편한 것 같기도...?그냥 파일시스템과 가장 비슷하다. 폴더 안에 페이지를 넣어서 정리하고, 같은 폴더 안에 있는 것끼리, 혹은 태그를 단 것끼리 묶어서graph를 생성한다.사실 graph는 많이 안 써봤다노션과 구조적으로 가장 다른 점은 아무래도 space 파일이 없다는 점이다. 노션은 파일들을 묶어놓은 폴더 자체도 하나의 파일이 되어서 폴더에 대한 안내... 뭐 그런 걸 쓸 수가 있는데 obsidian은 그런 게 없다. 물론 나는 확장 프로그램으로 쓰고 있다... 못버리는 기능 ㅎ실은 동기화를 git을 통해서 해야한다는 점만 제외하면 notion과 크게 다를 것도 없다. 입문에 벽 느끼지 않아도 된다.2. 정리 팁사실... 팁이랄 건 아니지만bold체와italic을 쓰는 나름의 기준을 두고 리스트랑 quotes랑 제목을 잘 사용하면 반은 간다고 생각한다,bold체를 소제목처럼 쓸 수도 있고, 출처는 인용으로 남기고... 그런 식으로?코드를 잘 구분하는 것도 중요함파일 정리는 폴더를 잘 만드는 사람이 승리한다... 저는 패배자임 하하어쨌든 그나마 예쁘게 쓸 수 있는 방법은 플러그인 적극 활용하기!!!!2. 플러그인 추천순정 상태의 obsidian은 대충 이런 느낌이다(테마는 적용되어 있음)가장 편하게 쓰고 있는 몇가지 플러그인을 소개하도록 하겠다.1. Make.md노션에서 넘어왔다면 추천. 정말 어마어마하게 많은 기능을 제공하고, 파일 정리를 쉽게 해주며, 위에서 말했던폴더 파일 생성을 가능하게 해준다.파일 별로 아이콘을 달아서 구별을 쉽게 해줄 수도 있고, 간단한 notion database 같은 기능도 제공한다.문서 편집 중에 inline context나 table을 쓸 수 있고,/를 붙여서 노션 처럼 메뉴를 사용할 수 있다.docs는 여기에 있다.https://www.make.md/docs/Getting%20StartedGetting Startedwww.make.md2. Gitobsidian sync가 유료 서비스이기 때문에 깃헙의 pull-commit을 통해서 동기화를 하는 방식이다.private repository를 하나 파고 연결해두면 다른 기기에서도 동기화가 가능하다.자동 커밋 interval을 설정해놓고 쓰면 된다.가아끔 merge conflict가 발생하긴 한다. 개발자라면... 쉽게 해결 가능.3. Style Setting테마에 관심이 있다면 꼭 깔아둘 것. 세부적인 세팅을 도와준다.작게는 H1~H6의 색이나 bold/italic 색상, 폰트, 배율은 물론이고 테마의 추가적인 배경화면, 투명도... 온갖 것들을 커스텀할 수 있도록 도와준다.지금은Blue Topaz테마를 쓰고 있는데, Make.md를 더한 내 세팅은 이런 느낌이다.다크모드도 있는데 라이트가 예뻐서 라이트 쓰는 중4. Auto Card Link작년 obsidian 소개글에서 그지같다고 욕한 link 삽입을 예쁘고 빠르게 할 수 있도록 돕는 플러그인이다. 이전에는 Embed Link를 썼었는데 워낙 느리고 오류도 많아서 블로그 댓글로 추천을 받아 갈아탔다.다만 모든 사이트에서 카드링크를 생성할 수 있는 건 아닌 듯.안되면 좀 별로다.5. Calendar데일리 노트를 자주 쓰는 사람이라면 추천. 가장 기본 캘린더이고, 좀 더 기능이 많고 디자인이 예쁜 것도 있다.달력 형태로 우측에 뜨면서 확인이 가능하다.task와 함께 쓰면 완료 못한 날에는 표시가 다르다.6. Taskstodo list를 task 형태로 관리할 수 있도록 도와준다.시작일 / 종료일 / 상태 등등 todo를 세밀하게 관리할 수 있도록 한다.데일리노트와 궁합이 좋음.여기까지가 내가 보기에 있으면 편한 플러그인 들이고, 아래는 개인적으로 만족하는 추가 플러그인.a. ExcaliDraw간단한 그리기... 마인드맵... 용도로 아주 편하다.b. Quick LaTexLaTex 문법을 자주 쓴다면 추천... 이미 문법을 알아야 쓸 수 있지만 어쨌든 편하긴 하다.c. Advanced Table테이블 쉽게 만들기 프로그램.표를 자주 쓴다면 추천!d. Data View페이지나 pdf, 사진, 어떤 데이터 든 보기 쉽게 정리할 수 있음notion의 database와 유사함약간 sql 감성의 지문으로 사용 가능4. 마무리 및 사용 후기노션보다 가독성이 좋다는 점에서 큰 점수를 준다. 확장성이 좋다는 점도 마음에 든다. 다만 공유 작업공간을 원하는 경우에는 당연히 노션이 좋다(obsidian은 이러니저러니 해도 오프라인 / 로컬 작업 용도이기 때문에).나는 주로 정리 목적으로 사용할 때는 obsidian을 쓰고, 공유문서가 필요할 때는 notion 혹은 google docs를 이용하는 편이다. 목적성에 따라서 나눠서 쓰면 좋을 것 같다.정리 봇, 대학원생, 논문 리서치봇... 모두에게 추천한다. 노션보다 문서 작성이 편하다.728x90공유하기게시글 관리ERROR DENY저작자표시비영리변경금지(새창열림)'🌠 etc.' 카테고리의 다른 글[Linux/CUDA] Ubuntu 24.04 LTS에 CUDA 및 Tensorflow GPU 설치하기(0)2025.01.15[Protocol] XKNX를 활용한 KNXnet/IP 데이터 통신하기(1)2023.12.15[Protocol] KNX Overview(1)2023.12.15[Obsidian] 커뮤니티 플러그인 추천 및 Git을 활용한 연동법(0)2023.10.20[Obsidian] Notion vs Obsidian, 내가 Obsidian으로 이사한 이유(3)2023.10.19",
        "created_at": "2025-04-21T08:24:47.718Z",
        "tags": [],
        "summary": "이 글은 Obsidian 노트 작성 프로그램을 1년간 사용한 후기를 담고 있으며, Notion과 비교하여 Obsidian의 장점과 사용법을 설명한다.  Obsidian은 엄격한 마크다운 문법을 사용하지만, 플러그인 활용을 통해 Notion과 유사한 기능을 구현하고, Git 연동으로 효율적인 백업 및 동기화가 가능하다.  저자는 개인적으로 정리 및 연구 목적으로 Obsidian을, 공유 및 협업에는 Notion을 사용하는 것을 추천하며, 특히 정리 및 연구가 필요한 사람들에게 Obsidian을 강력하게 추천한다.\n"
    },
    {
        "title": "오픈AI·딥시크도 1%대에 그친 강력한 AGI 벤치마크 등장",
        "url": "https://www.aitimes.com/news/articleView.html?idxno=169097",
        "source": "raindrop",
        "body": "www.aitimes.com발행일: 2025-07-04 19:03 (금)로그인한국어KR영어EN일본어JP중국어CH뉴스레터 신청",
        "created_at": "2025-03-29T07:45:05.689Z",
        "tags": [],
        "summary": "AI타임스(www.aitimes.com)는 2025년 7월 4일 금요일 오후 7시 3분에 뉴스를 발행했습니다.  해당 기사는 한국어, 영어, 일본어, 중국어로 제공되며 뉴스레터 신청도 가능합니다.  AI타임스 웹사이트에서 다양한 언어로 AI 관련 뉴스를 확인할 수 있습니다.\n"
    },
    {
        "title": "트랜스포머를 넘어 MoE와 SSM까지, 미래 AI의 방향은? | AGI 구현 위한 요구 컴퓨팅 량 너무 높아 | MoE, Mamba, Jamba 등 AI 아키텍처 등장",
        "url": "https://www.youtube.com/watch?v=NSt259rpsKM",
        "source": "youtube",
        "channel_title": "안될공학 - IT 테크 신기술",
        "published_at": "2024-11-27T09:00:19Z",
        "view_count": "59712",
        "like_count": "2061",
        "comment_count": "121",
        "video_id": "NSt259rpsKM",
        "body": "",
        "summary": ""
    },
    {
        "title": "Diffusion LoRa",
        "url": "file:///Users/joonpark/Documents/Obsidian/Obsidian/Diffusion LoRa.md",
        "source": "obsidian",
        "body": "```dataviewjs\n// ==================== 설정 영역 ====================\n// 이 부분만 수정하면 모든 기능을 커스터마이징할 수 있습니다!\n\n// 📁 폴더 설정\nconst FOLDER_CONFIG = {\n    path: \"Clippings/Models\",           // 대상 폴더\n    filterBy: \"tags\",          // 필터링할 속성\n    filterValue: \"lora\"    // 필터링 값 (소문자로 변환됨)\n};\n\n// 🏷️ 속성 정의 및 한글명 매핑\nconst PROPERTIES = {\n    // 기본 속성들\n    title: { ko: \"제목\", type: \"text\", icon: \"📄\" },\n    description: { ko: \"설명\", type: \"text\", icon: \"📝\" },\n    author: { ko: \"작성자\", type: \"text\", icon: \"👤\" },\n    tags: { ko: \"태그\", type: \"list\", icon: \"🏷️\" },\n    \n    // 평가 관련\n    rating: { ko: \"별점\", type: \"number\", icon: \"⭐\", min: 1, max: 5 },\n    likes: { ko: \"좋아요\", type: \"number\", icon: \"❤️\" },\n    priority: { ko: \"중요도\", type: \"select\", icon: \"🚦\", \n        options: {\n            'High': '🔴 높음', 'Medium': '🟡 보통', 'Low': '🟢 낮음',\n            '높음': '🔴 높음', '중간': '🟡 보통', '낮음': '🟢 낮음'\n        }\n    },\n    \n    // 상태 관련\n    status: { ko: \"상태\", type: \"select\", icon: \"📋\",\n        options: {\n            'TODO': '📋 할 일', 'IN_PROGRESS': '⚡ 진행중', 'DONE': '✅ 완료',\n            'REVIEW': '👀 검토중', 'ARCHIVED': '📦 보관됨'\n        }\n    },\n    \n    // 날짜 관련\n    created: { ko: \"생성일\", type: \"date\", icon: \"📅\" },\n    modified: { ko: \"수정일\", type: \"date\", icon: \"🔄\" },\n    \n    // 커스텀 속성들 (필요에 따라 추가)\n    category: { ko: \"카테고리\", type: \"text\", icon: \"📂\" },\n    difficulty: { ko: \"난이도\", type: \"select\", icon: \"📊\",\n        options: {\n            'Easy': '🟢 쉬움', 'Medium': '🟡 보통', 'Hard': '🔴 어려움'\n        }\n    }\n};\n\n// 🎯 그룹핑 설정\nconst GROUPING_CONFIG = {\n    // 사용할 그룹핑 방식 선택 (하나만 활성화)\n    active: \"tags\",  // rating, priority, tags, author, status, created, category 등\n    \n    // 그룹별 특별 설정\n    settings: {\n        tags: {\n            allowMultiple: true,    // 한 파일이 여러 그룹에 속할 수 있음\n            emptyLabel: \"태그 없음\"\n        },\n        rating: {\n            sortOrder: \"desc\",      // desc: 높은 점수부터, asc: 낮은 점수부터\n            emptyLabel: \"평점 없음\"\n        },\n        created: {\n            format: \"yyyy-MM\",      // 날짜 포맷 (년-월)\n            emptyLabel: \"날짜 없음\"\n        }\n    }\n};\n\n// 📊 정렬 설정 (그룹 내에서의 정렬)\nconst SORTING_CONFIG = [\n    { field: \"rating\", order: \"desc\" },     // 1순위: 별점 높은 순\n    { field: \"priority\", order: \"asc\" },    // 2순위: 중요도 높은 순\n    { field: \"likes\", order: \"desc\" },      // 3순위: 좋아요 많은 순\n    { field: \"title\", order: \"asc\" }        // 4순위: 제목 알파벳 순\n];\n\n// 🗂️ 테이블 컬럼 설정 (순서 중요! 왼쪽부터 표시됨)\nconst TABLE_COLUMNS = [\n    { field: \"title\", width: \"200px\" },      // 파일 이름\n    { field: \"image\", width: \"180px\" },      // 첫 번째 이미지\n    { field: \"rating\", width: \"120px\" },     // 별점  \n    { field: \"tags\", width: \"150px\" },       // 태그\n    { field: \"priority\", width: \"100px\" },   // 중요도\n    { field: \"likes\", width: \"80px\" },       // 좋아요\n    { field: \"description\", width: \"300px\" } // 설명\n];\n\n// 🎨 테이블 스타일 설정\nconst TABLE_STYLE = {\n    // 컬럼 너비 조절\n    enableColumnWidth: true,    // 컬럼 너비 적용 여부\n    \n    // 테이블 전체 설정\n    tableWidth: \"100%\",         // 테이블 전체 너비 (100%, 1200px 등)\n    maxTableHeight: \"600px\",    // 테이블 최대 높이 (스크롤)\n    \n    // 셀 스타일\n    cellPadding: \"8px\",         // 셀 안쪽 여백\n    cellAlignment: {            // 컬럼별 정렬\n        \"title\": \"left\",\n        \"image\": \"center\",\n        \"rating\": \"center\", \n        \"tags\": \"left\",\n        \"priority\": \"center\",\n        \"likes\": \"center\",\n        \"description\": \"left\"\n    },\n    \n    // 텍스트 설정\n    fontSize: \"14px\",           // 글자 크기\n    lineHeight: \"1.4\",          // 줄 간격\n    \n    // 색상 테마\n    headerBgColor: \"#f0f0f0\",   // 헤더 배경색\n    evenRowBgColor: \"#f9f9f9\",  // 짝수 행 배경색\n    hoverColor: \"#e6f3ff\"       // 마우스 오버 색상\n};\n\n// 🎨 표시 설정\nconst DISPLAY_CONFIG = {\n    showStats: true,           // 전체 통계 표시\n    showGroupCount: true,      // 그룹별 파일 수 표시\n    showImages: true,          // 이미지 표시\n    imageSize: 150,           // 이미지 크기\n    showEmptyGroups: false,   // 빈 그룹 표시 여부\n    maxDescriptionLength: 100 // 설명 최대 길이\n};\n\n// ==================== 메인 로직 ====================\n// 파일 선택\nconst files = dv.pages(`\"${FOLDER_CONFIG.path}\"`)\n    .where(p => {\n        if (!FOLDER_CONFIG.filterBy || !FOLDER_CONFIG.filterValue) return true;\n        \n        const filterField = p[FOLDER_CONFIG.filterBy];\n        if (!filterField) return false;\n        \n        const filterString = Array.isArray(filterField)\n            ? filterField.map(item => (item.path || item)).join(' ')\n            : String(filterField);\n        return filterString.toLowerCase().includes(FOLDER_CONFIG.filterValue.toLowerCase());\n    });\n\n// 속성 값 가져오기 함수\nconst getPropertyValue = (page, propName) => {\n    const prop = PROPERTIES[propName];\n    const value = page[propName];\n    \n    if (!value && propName === \"title\") return page.file?.name || \"제목 없음\";\n    if (!value && propName === \"created\") return page.file?.cday;\n    if (!value && propName === \"modified\") return page.file?.mday;\n    \n    return value;\n};\n\n// 그룹 키 생성 함수\nconst getGroupKey = (page, groupField) => {\n    const prop = PROPERTIES[groupField];\n    const value = getPropertyValue(page, groupField);\n    const settings = GROUPING_CONFIG.settings[groupField] || {};\n    \n    if (!value || (Array.isArray(value) && value.length === 0)) {\n        return settings.emptyLabel || `${prop?.ko || groupField} 없음`;\n    }\n    \n    // 태그는 배열로 반환 (여러 그룹에 속할 수 있음)\n    if (groupField === \"tags\") {\n        return Array.isArray(value) ? value : [value];\n    }\n    \n    // 선택형 속성은 한글명으로 변환\n    if (prop?.type === \"select\" && prop.options && prop.options[value]) {\n        return prop.options[value];\n    }\n    \n    // 날짜 포맷팅\n    if (prop?.type === \"date\" && value && settings.format) {\n        return `${prop.icon} ${value.toFormat(settings.format)}`;\n    }\n    \n    // 기본 포맷\n    return `${prop?.icon || \"\"} ${value}`.trim();\n};\n\n// 그룹핑 실행\nlet groupedPages;\nconst groupField = GROUPING_CONFIG.active;\nconst groupSettings = GROUPING_CONFIG.settings[groupField] || {};\n\nif (groupSettings.allowMultiple) {\n    // 여러 그룹에 속할 수 있는 경우 (예: tags)\n    groupedPages = files\n        .flatMap(p => {\n            const groups = getGroupKey(p, groupField);\n            const groupArray = Array.isArray(groups) ? groups : [groups];\n            return groupArray.map(group => ({ group: group, page: p }));\n        })\n        .groupBy(item => item.group);\n} else {\n    // 하나의 그룹에만 속하는 경우\n    groupedPages = files\n        .map(p => ({ group: getGroupKey(p, groupField), page: p }))\n        .groupBy(item => item.group);\n}\n\n// 정렬 함수\nconst sortPages = (pages) => {\n    return Array.from(pages).sort((a, b) => {\n        try {\n            const pA = groupSettings.allowMultiple ? a?.page : a?.page;\n            const pB = groupSettings.allowMultiple ? b?.page : b?.page;\n            \n            if (!pA || !pB) return pA ? -1 : pB ? 1 : 0;\n            \n            // 설정된 정렬 기준에 따라 순차적으로 정렬\n            for (let sortConfig of SORTING_CONFIG) {\n                const fieldA = getPropertyValue(pA, sortConfig.field);\n                const fieldB = getPropertyValue(pB, sortConfig.field);\n                \n                // 숫자 타입 처리\n                if (PROPERTIES[sortConfig.field]?.type === \"number\") {\n                    const numA = Number(fieldA) || 0;\n                    const numB = Number(fieldB) || 0;\n                    if (numA !== numB) {\n                        return sortConfig.order === \"desc\" ? numB - numA : numA - numB;\n                    }\n                }\n                \n                // 선택형 타입 처리 (우선순위 등)\n                else if (PROPERTIES[sortConfig.field]?.type === \"select\") {\n                    const prop = PROPERTIES[sortConfig.field];\n                    const orderA = Object.keys(prop.options || {}).indexOf(fieldA);\n                    const orderB = Object.keys(prop.options || {}).indexOf(fieldB);\n                    if (orderA !== orderB) {\n                        return sortConfig.order === \"desc\" ? orderB - orderA : orderA - orderB;\n                    }\n                }\n                \n                // 문자열 타입 처리\n                else {\n                    const strA = String(fieldA || '');\n                    const strB = String(fieldB || '');\n                    const comparison = strA.localeCompare(strB);\n                    if (comparison !== 0) {\n                        return sortConfig.order === \"desc\" ? -comparison : comparison;\n                    }\n                }\n            }\n            \n            return 0;\n        } catch (error) {\n            console.error(\"정렬 중 오류:\", error);\n            return 0;\n        }\n    });\n};\n\n// 그룹 정렬\nconst sortedGroups = Array.from(groupedPages)\n    .sort((a, b) => {\n        // 그룹 자체의 정렬 로직\n        const prop = PROPERTIES[groupField];\n        if (prop?.type === \"number\") {\n            const numA = parseFloat(a.key.replace(/[^\\d.-]/g, '')) || 0;\n            const numB = parseFloat(b.key.replace(/[^\\d.-]/g, '')) || 0;\n            return numB - numA; // 숫자는 큰 것부터\n        }\n        return a.key.localeCompare(b.key); // 문자는 알파벳 순\n    });\n\n// 통계 출력\nif (DISPLAY_CONFIG.showStats) {\n    const propInfo = PROPERTIES[groupField];\n    dv.header(2, `📊 ${propInfo?.ko || groupField}별 통계`);\n    dv.paragraph(`총 **${files.length}개** 파일이 **${sortedGroups.length}개** 그룹으로 분류되었습니다.`);\n}\n\n// 각 그룹 처리\nfor (let group of sortedGroups) {\n    if (!DISPLAY_CONFIG.showEmptyGroups && group.rows.length === 0) continue;\n    \n    // 그룹 헤더\n    const countText = DISPLAY_CONFIG.showGroupCount ? ` (${group.rows.length}개)` : '';\n    dv.header(3, `${group.key}${countText}`);\n    \n    // 파일들 정렬\n    const sortedFiles = sortPages(group.rows);\n    \n    // 테이블 데이터 준비\n    let tableRows = [];\n    for (let item of sortedFiles) {\n        const file = groupSettings.allowMultiple ? item?.page : item?.page;\n        if (!file) continue;\n        \n        let row = [];\n        \n        for (let colConfig of TABLE_COLUMNS) {\n            const colName = typeof colConfig === 'string' ? colConfig : colConfig.field;\n            if (colName === \"image\") {\n                // 이미지 처리\n                if (DISPLAY_CONFIG.showImages) {\n                    let imagePath = \"이미지 없음\";\n                    try {\n                        if (file.file?.path) {\n                            const fileContent = await dv.io.load(file.file.path);\n                            const imageMatch = fileContent.match(/!\\[.*?\\]\\((.*?)\\)|!\\[.*?\\]\\<\\s*(.*?)\\s*\\>/);\n                            if (imageMatch) {\n                                const extractedPath = imageMatch[1] || imageMatch[2];\n                                imagePath = `![](${extractedPath}|${DISPLAY_CONFIG.imageSize})`;\n                            }\n                        }\n                    } catch (e) {\n                        imagePath = \"이미지 로드 오류\";\n                    }\n                    row.push(imagePath);\n                }\n            } else if (colName === \"title\") {\n                // 파일명과 편집 버튼을 함께 표시\n                const fileLink = file.file?.link || \"링크 없음\";\n                row.push(fileLink);\n            } else {\n                const prop = PROPERTIES[colName];\n                let value = getPropertyValue(file, colName);\n                \n                // 값 포맷팅\n                if (value) {\n                    if (prop?.type === \"select\" && prop.options && prop.options[value]) {\n                        value = prop.options[value];\n                    } else if (colName === \"rating\") {\n                        // 별점을 노란색 채운 별과 빈 별로 시각적으로 표시\n                        const filledStars = \"⭐\".repeat(value);\n                        const emptyStars = \"☆\".repeat(5 - value);\n                        value = `${filledStars}${emptyStars} ${value}`;\n                    } else if (prop?.type === \"number\" && prop?.icon) {\n                        value = `${prop.icon} ${value}`;\n                    } else if (colName === \"description\" && value.length > DISPLAY_CONFIG.maxDescriptionLength) {\n                        value = value.substring(0, DISPLAY_CONFIG.maxDescriptionLength) + \"...\";\n                    } else if (Array.isArray(value)) {\n                        value = value.join(\", \");\n                    }\n                }\n                \n                row.push(value ?? \"N/A\");\n            }\n        }\n        \n        tableRows.push(row);\n    }\n    \n    // 테이블 헤더 생성\n    const headers = TABLE_COLUMNS.map(col => {\n        const colName = typeof col === 'string' ? col : col.field;\n        if (colName === \"image\") return \"이미지\";\n        if (colName === \"title\") return \"파일 이름\";\n        return PROPERTIES[colName]?.ko || colName;\n    });\n    \n    // CSS 스타일 적용\n    let tableStyle = \"\";\n    if (TABLE_STYLE.enableColumnWidth) {\n        tableStyle = `<style>\n            .dataview-table {\n                width: ${TABLE_STYLE.tableWidth};\n                max-height: ${TABLE_STYLE.maxTableHeight};\n                overflow-y: auto;\n                font-size: ${TABLE_STYLE.fontSize};\n                line-height: ${TABLE_STYLE.lineHeight};\n            }\n            \n            .dataview-table table {\n                width: 100%;\n                border-collapse: collapse;\n            }\n            \n            .dataview-table th {\n                background-color: ${TABLE_STYLE.headerBgColor};\n                padding: ${TABLE_STYLE.cellPadding};\n                font-weight: bold;\n                border: 1px solid #ddd;\n                position: sticky;\n                top: 0;\n                z-index: 10;\n            }\n            \n            .dataview-table td {\n                padding: ${TABLE_STYLE.cellPadding};\n                border: 1px solid #ddd;\n                vertical-align: top;\n            }\n            \n            .dataview-table tbody tr:nth-child(even) {\n                background-color: ${TABLE_STYLE.evenRowBgColor};\n            }\n            \n            .dataview-table tbody tr:hover {\n                background-color: ${TABLE_STYLE.hoverColor};\n            }\n            \n            ${TABLE_COLUMNS.map((col, index) => {\n                const colName = typeof col === 'string' ? col : col.field;\n                const width = typeof col === 'object' ? col.width : 'auto';\n                const alignment = TABLE_STYLE.cellAlignment[colName] || 'left';\n                return `\n                .dataview-table th:nth-child(${index + 1}),\n                .dataview-table td:nth-child(${index + 1}) {\n                    width: ${width};\n                    text-align: ${alignment};\n                    ${colName === 'description' ? 'word-wrap: break-word; max-width: 0;' : ''}\n                }`;\n            }).join('')}\n        </style>`;\n        \n        // 스타일을 한 번만 적용\n        if (group === sortedGroups[0]) {\n            dv.paragraph(tableStyle);\n        }\n    }\n    \n    // 테이블 출력 (CSS 클래스 적용)\n    if (tableRows.length > 0) {\n        dv.el(\"div\", \"\", { cls: \"dataview-table\" });\n        dv.table(headers, tableRows);\n    }\n}\n\n// 설정 안내\ndv.header(4, \"⚙️ 커스터마이징 가이드\");\ndv.paragraph(\"📝 **프로퍼티 편집**: 파일명을 클릭해서 노트를 열고 Metadata Menu로 수정하세요!\");\ndv.paragraph(\"⚙️ **설정 변경**: 코드 상단의 설정 영역에서 그룹핑, 정렬, 컬럼 등을 자유롭게 수정할 수 있습니다!\");\n```",
        "file_path": "/Users/joonpark/Documents/Obsidian/Obsidian/Diffusion LoRa.md",
        "summary": "이 코드는 Obsidian DataviewJS 플러그인을 사용하여 특정 폴더(`Clippings/Models`) 내의 \"lora\" 태그가 포함된 파일들을  사용자 정의 속성(제목, 설명, 별점, 태그 등)에 따라 그룹화하고, 정렬하여 테이블 형태로 표시하는 스크립트입니다.  사용자는 코드 상단의 설정 영역에서 폴더 경로, 필터링 조건,  속성 정의, 그룹핑 방식, 정렬 순서, 테이블 컬럼 및 스타일 등을 자유롭게 변경하여  원하는 형태로 데이터를 표시할 수 있습니다.  결과는 그룹별 통계와 함께 사용자 지정된 테이블로 출력됩니다.\n"
    },
    {
        "title": "Models - LoRa",
        "url": "file:///Users/joonpark/Documents/Obsidian/Obsidian/Models - LoRa.md",
        "source": "obsidian",
        "body": "```dataviewjs\n// ==================== 설정 영역 ====================\n// 이 부분만 수정하면 모든 기능을 커스터마이징할 수 있습니다!\n\n// 📁 폴더 설정\nconst FOLDER_CONFIG = {\n    path: \"Clippings/Models\",           // 대상 폴더\n    filterBy: \"tags\",          // 필터링할 속성\n    filterValue: \"lora\"    // 필터링 값 (소문자로 변환됨)\n};\n\n// 🏷️ 속성 정의 및 한글명 매핑\nconst PROPERTIES = {\n    // 기본 속성들\n    title: { ko: \"제목\", type: \"text\", icon: \"📄\" },\n    description: { ko: \"설명\", type: \"text\", icon: \"📝\" },\n    author: { ko: \"작성자\", type: \"text\", icon: \"👤\" },\n    tags: { ko: \"태그\", type: \"list\", icon: \"🏷️\" },\n    \n    // 평가 관련\n    rating: { ko: \"별점\", type: \"number\", icon: \"⭐\", min: 1, max: 5 },\n    likes: { ko: \"좋아요\", type: \"number\", icon: \"❤️\" },\n    priority: { ko: \"중요도\", type: \"select\", icon: \"🚦\", \n        options: {\n            'High': '🔴 높음', 'Medium': '🟡 보통', 'Low': '🟢 낮음',\n            '높음': '🔴 높음', '중간': '🟡 보통', '낮음': '🟢 낮음'\n        }\n    },\n    \n    // 상태 관련\n    status: { ko: \"상태\", type: \"select\", icon: \"📋\",\n        options: {\n            'TODO': '📋 할 일', 'IN_PROGRESS': '⚡ 진행중', 'DONE': '✅ 완료',\n            'REVIEW': '👀 검토중', 'ARCHIVED': '📦 보관됨'\n        }\n    },\n    \n    // 날짜 관련\n    created: { ko: \"생성일\", type: \"date\", icon: \"📅\" },\n    modified: { ko: \"수정일\", type: \"date\", icon: \"🔄\" },\n    \n    // 커스텀 속성들 (필요에 따라 추가)\n    category: { ko: \"카테고리\", type: \"text\", icon: \"📂\" },\n    difficulty: { ko: \"난이도\", type: \"select\", icon: \"📊\",\n        options: {\n            'Easy': '🟢 쉬움', 'Medium': '🟡 보통', 'Hard': '🔴 어려움'\n        }\n    }\n};\n\n// 🎯 그룹핑 설정\nconst GROUPING_CONFIG = {\n    // 사용할 그룹핑 방식 선택 (하나만 활성화)\n    active: \"tags\",  // rating, priority, tags, author, status, created, category 등\n    \n    // 그룹별 특별 설정\n    settings: {\n        tags: {\n            allowMultiple: true,    // 한 파일이 여러 그룹에 속할 수 있음\n            emptyLabel: \"태그 없음\"\n        },\n        rating: {\n            sortOrder: \"desc\",      // desc: 높은 점수부터, asc: 낮은 점수부터\n            emptyLabel: \"평점 없음\"\n        },\n        created: {\n            format: \"yyyy-MM\",      // 날짜 포맷 (년-월)\n            emptyLabel: \"날짜 없음\"\n        }\n    }\n};\n\n// 📊 정렬 설정 (그룹 내에서의 정렬)\nconst SORTING_CONFIG = [\n    { field: \"rating\", order: \"desc\" },     // 1순위: 별점 높은 순\n    { field: \"priority\", order: \"asc\" },    // 2순위: 중요도 높은 순\n    { field: \"likes\", order: \"desc\" },      // 3순위: 좋아요 많은 순\n    { field: \"title\", order: \"asc\" }        // 4순위: 제목 알파벳 순\n];\n\n// 🗂️ 테이블 컬럼 설정 (순서 중요! 왼쪽부터 표시됨)\nconst TABLE_COLUMNS = [\n    { field: \"title\", width: \"200px\" },      // 파일 이름\n    { field: \"image\", width: \"180px\" },      // 첫 번째 이미지\n    { field: \"rating\", width: \"120px\" },     // 별점  \n    { field: \"tags\", width: \"150px\" },       // 태그\n    { field: \"priority\", width: \"100px\" },   // 중요도\n    { field: \"likes\", width: \"80px\" },       // 좋아요\n    { field: \"description\", width: \"300px\" } // 설명\n];\n\n// 🎨 테이블 스타일 설정\nconst TABLE_STYLE = {\n    // 컬럼 너비 조절\n    enableColumnWidth: true,    // 컬럼 너비 적용 여부\n    \n    // 테이블 전체 설정\n    tableWidth: \"100%\",         // 테이블 전체 너비 (100%, 1200px 등)\n    maxTableHeight: \"600px\",    // 테이블 최대 높이 (스크롤)\n    \n    // 셀 스타일\n    cellPadding: \"8px\",         // 셀 안쪽 여백\n    cellAlignment: {            // 컬럼별 정렬\n        \"title\": \"left\",\n        \"image\": \"center\",\n        \"rating\": \"center\", \n        \"tags\": \"left\",\n        \"priority\": \"center\",\n        \"likes\": \"center\",\n        \"description\": \"left\"\n    },\n    \n    // 텍스트 설정\n    fontSize: \"14px\",           // 글자 크기\n    lineHeight: \"1.4\",          // 줄 간격\n    \n    // 색상 테마\n    headerBgColor: \"#f0f0f0\",   // 헤더 배경색\n    evenRowBgColor: \"#f9f9f9\",  // 짝수 행 배경색\n    hoverColor: \"#e6f3ff\"       // 마우스 오버 색상\n};\n\n// 🎨 표시 설정\nconst DISPLAY_CONFIG = {\n    showStats: true,           // 전체 통계 표시\n    showGroupCount: true,      // 그룹별 파일 수 표시\n    showImages: true,          // 이미지 표시\n    imageSize: 150,           // 이미지 크기\n    showEmptyGroups: false,   // 빈 그룹 표시 여부\n    maxDescriptionLength: 100 // 설명 최대 길이\n};\n\n// ==================== 메인 로직 ====================\n// 파일 선택\nconst files = dv.pages(`\"${FOLDER_CONFIG.path}\"`)\n    .where(p => {\n        if (!FOLDER_CONFIG.filterBy || !FOLDER_CONFIG.filterValue) return true;\n        \n        const filterField = p[FOLDER_CONFIG.filterBy];\n        if (!filterField) return false;\n        \n        const filterString = Array.isArray(filterField)\n            ? filterField.map(item => (item.path || item)).join(' ')\n            : String(filterField);\n        return filterString.toLowerCase().includes(FOLDER_CONFIG.filterValue.toLowerCase());\n    });\n\n// 속성 값 가져오기 함수\nconst getPropertyValue = (page, propName) => {\n    const prop = PROPERTIES[propName];\n    const value = page[propName];\n    \n    if (!value && propName === \"title\") return page.file?.name || \"제목 없음\";\n    if (!value && propName === \"created\") return page.file?.cday;\n    if (!value && propName === \"modified\") return page.file?.mday;\n    \n    return value;\n};\n\n// 그룹 키 생성 함수\nconst getGroupKey = (page, groupField) => {\n    const prop = PROPERTIES[groupField];\n    const value = getPropertyValue(page, groupField);\n    const settings = GROUPING_CONFIG.settings[groupField] || {};\n    \n    if (!value || (Array.isArray(value) && value.length === 0)) {\n        return settings.emptyLabel || `${prop?.ko || groupField} 없음`;\n    }\n    \n    // 태그는 배열로 반환 (여러 그룹에 속할 수 있음)\n    if (groupField === \"tags\") {\n        return Array.isArray(value) ? value : [value];\n    }\n    \n    // 선택형 속성은 한글명으로 변환\n    if (prop?.type === \"select\" && prop.options && prop.options[value]) {\n        return prop.options[value];\n    }\n    \n    // 날짜 포맷팅\n    if (prop?.type === \"date\" && value && settings.format) {\n        return `${prop.icon} ${value.toFormat(settings.format)}`;\n    }\n    \n    // 기본 포맷\n    return `${prop?.icon || \"\"} ${value}`.trim();\n};\n\n// 그룹핑 실행\nlet groupedPages;\nconst groupField = GROUPING_CONFIG.active;\nconst groupSettings = GROUPING_CONFIG.settings[groupField] || {};\n\nif (groupSettings.allowMultiple) {\n    // 여러 그룹에 속할 수 있는 경우 (예: tags)\n    groupedPages = files\n        .flatMap(p => {\n            const groups = getGroupKey(p, groupField);\n            const groupArray = Array.isArray(groups) ? groups : [groups];\n            return groupArray.map(group => ({ group: group, page: p }));\n        })\n        .groupBy(item => item.group);\n} else {\n    // 하나의 그룹에만 속하는 경우\n    groupedPages = files\n        .map(p => ({ group: getGroupKey(p, groupField), page: p }))\n        .groupBy(item => item.group);\n}\n\n// 정렬 함수\nconst sortPages = (pages) => {\n    return Array.from(pages).sort((a, b) => {\n        try {\n            const pA = groupSettings.allowMultiple ? a?.page : a?.page;\n            const pB = groupSettings.allowMultiple ? b?.page : b?.page;\n            \n            if (!pA || !pB) return pA ? -1 : pB ? 1 : 0;\n            \n            // 설정된 정렬 기준에 따라 순차적으로 정렬\n            for (let sortConfig of SORTING_CONFIG) {\n                const fieldA = getPropertyValue(pA, sortConfig.field);\n                const fieldB = getPropertyValue(pB, sortConfig.field);\n                \n                // 숫자 타입 처리\n                if (PROPERTIES[sortConfig.field]?.type === \"number\") {\n                    const numA = Number(fieldA) || 0;\n                    const numB = Number(fieldB) || 0;\n                    if (numA !== numB) {\n                        return sortConfig.order === \"desc\" ? numB - numA : numA - numB;\n                    }\n                }\n                \n                // 선택형 타입 처리 (우선순위 등)\n                else if (PROPERTIES[sortConfig.field]?.type === \"select\") {\n                    const prop = PROPERTIES[sortConfig.field];\n                    const orderA = Object.keys(prop.options || {}).indexOf(fieldA);\n                    const orderB = Object.keys(prop.options || {}).indexOf(fieldB);\n                    if (orderA !== orderB) {\n                        return sortConfig.order === \"desc\" ? orderB - orderA : orderA - orderB;\n                    }\n                }\n                \n                // 문자열 타입 처리\n                else {\n                    const strA = String(fieldA || '');\n                    const strB = String(fieldB || '');\n                    const comparison = strA.localeCompare(strB);\n                    if (comparison !== 0) {\n                        return sortConfig.order === \"desc\" ? -comparison : comparison;\n                    }\n                }\n            }\n            \n            return 0;\n        } catch (error) {\n            console.error(\"정렬 중 오류:\", error);\n            return 0;\n        }\n    });\n};\n\n// 그룹 정렬\nconst sortedGroups = Array.from(groupedPages)\n    .sort((a, b) => {\n        // 그룹 자체의 정렬 로직\n        const prop = PROPERTIES[groupField];\n        if (prop?.type === \"number\") {\n            const numA = parseFloat(a.key.replace(/[^\\d.-]/g, '')) || 0;\n            const numB = parseFloat(b.key.replace(/[^\\d.-]/g, '')) || 0;\n            return numB - numA; // 숫자는 큰 것부터\n        }\n        return a.key.localeCompare(b.key); // 문자는 알파벳 순\n    });\n\n// 통계 출력\nif (DISPLAY_CONFIG.showStats) {\n    const propInfo = PROPERTIES[groupField];\n    dv.header(2, `📊 ${propInfo?.ko || groupField}별 통계`);\n    dv.paragraph(`총 **${files.length}개** 파일이 **${sortedGroups.length}개** 그룹으로 분류되었습니다.`);\n}\n\n// 각 그룹 처리\nfor (let group of sortedGroups) {\n    if (!DISPLAY_CONFIG.showEmptyGroups && group.rows.length === 0) continue;\n    \n    // 그룹 헤더\n    const countText = DISPLAY_CONFIG.showGroupCount ? ` (${group.rows.length}개)` : '';\n    dv.header(3, `${group.key}${countText}`);\n    \n    // 파일들 정렬\n    const sortedFiles = sortPages(group.rows);\n    \n    // 테이블 데이터 준비\n    let tableRows = [];\n    for (let item of sortedFiles) {\n        const file = groupSettings.allowMultiple ? item?.page : item?.page;\n        if (!file) continue;\n        \n        let row = [];\n        \n        for (let colConfig of TABLE_COLUMNS) {\n            const colName = typeof colConfig === 'string' ? colConfig : colConfig.field;\n            if (colName === \"image\") {\n                // 이미지 처리\n                if (DISPLAY_CONFIG.showImages) {\n                    let imagePath = \"이미지 없음\";\n                    try {\n                        if (file.file?.path) {\n                            const fileContent = await dv.io.load(file.file.path);\n                            const imageMatch = fileContent.match(/!\\[.*?\\]\\((.*?)\\)|!\\[.*?\\]\\<\\s*(.*?)\\s*\\>/);\n                            if (imageMatch) {\n                                const extractedPath = imageMatch[1] || imageMatch[2];\n                                imagePath = `![](${extractedPath}|${DISPLAY_CONFIG.imageSize})`;\n                            }\n                        }\n                    } catch (e) {\n                        imagePath = \"이미지 로드 오류\";\n                    }\n                    row.push(imagePath);\n                }\n            } else if (colName === \"title\") {\n                // 파일명과 편집 버튼을 함께 표시\n                const fileLink = file.file?.link || \"링크 없음\";\n                row.push(fileLink);\n            } else {\n                const prop = PROPERTIES[colName];\n                let value = getPropertyValue(file, colName);\n                \n                // 값 포맷팅\n                if (value) {\n                    if (prop?.type === \"select\" && prop.options && prop.options[value]) {\n                        value = prop.options[value];\n                    } else if (colName === \"rating\") {\n                        // 별점을 노란색 채운 별과 빈 별로 시각적으로 표시\n                        const filledStars = \"⭐\".repeat(value);\n                        const emptyStars = \"☆\".repeat(5 - value);\n                        value = `${filledStars}${emptyStars} ${value}`;\n                    } else if (prop?.type === \"number\" && prop?.icon) {\n                        value = `${prop.icon} ${value}`;\n                    } else if (colName === \"description\" && value.length > DISPLAY_CONFIG.maxDescriptionLength) {\n                        value = value.substring(0, DISPLAY_CONFIG.maxDescriptionLength) + \"...\";\n                    } else if (Array.isArray(value)) {\n                        value = value.join(\", \");\n                    }\n                }\n                \n                row.push(value ?? \"N/A\");\n            }\n        }\n        \n        tableRows.push(row);\n    }\n    \n    // 테이블 헤더 생성\n    const headers = TABLE_COLUMNS.map(col => {\n        const colName = typeof col === 'string' ? col : col.field;\n        if (colName === \"image\") return \"이미지\";\n        if (colName === \"title\") return \"파일 이름\";\n        return PROPERTIES[colName]?.ko || colName;\n    });\n    \n    // CSS 스타일 적용\n    let tableStyle = \"\";\n    if (TABLE_STYLE.enableColumnWidth) {\n        tableStyle = `<style>\n            .dataview-table {\n                width: ${TABLE_STYLE.tableWidth};\n                max-height: ${TABLE_STYLE.maxTableHeight};\n                overflow-y: auto;\n                font-size: ${TABLE_STYLE.fontSize};\n                line-height: ${TABLE_STYLE.lineHeight};\n            }\n            \n            .dataview-table table {\n                width: 100%;\n                border-collapse: collapse;\n            }\n            \n            .dataview-table th {\n                background-color: ${TABLE_STYLE.headerBgColor};\n                padding: ${TABLE_STYLE.cellPadding};\n                font-weight: bold;\n                border: 1px solid #ddd;\n                position: sticky;\n                top: 0;\n                z-index: 10;\n            }\n            \n            .dataview-table td {\n                padding: ${TABLE_STYLE.cellPadding};\n                border: 1px solid #ddd;\n                vertical-align: top;\n            }\n            \n            .dataview-table tbody tr:nth-child(even) {\n                background-color: ${TABLE_STYLE.evenRowBgColor};\n            }\n            \n            .dataview-table tbody tr:hover {\n                background-color: ${TABLE_STYLE.hoverColor};\n            }\n            \n            ${TABLE_COLUMNS.map((col, index) => {\n                const colName = typeof col === 'string' ? col : col.field;\n                const width = typeof col === 'object' ? col.width : 'auto';\n                const alignment = TABLE_STYLE.cellAlignment[colName] || 'left';\n                return `\n                .dataview-table th:nth-child(${index + 1}),\n                .dataview-table td:nth-child(${index + 1}) {\n                    width: ${width};\n                    text-align: ${alignment};\n                    ${colName === 'description' ? 'word-wrap: break-word; max-width: 0;' : ''}\n                }`;\n            }).join('')}\n        </style>`;\n        \n        // 스타일을 한 번만 적용\n        if (group === sortedGroups[0]) {\n            dv.paragraph(tableStyle);\n        }\n    }\n    \n    // 테이블 출력 (CSS 클래스 적용)\n    if (tableRows.length > 0) {\n        dv.el(\"div\", \"\", { cls: \"dataview-table\" });\n        dv.table(headers, tableRows);\n    }\n}\n\n// 설정 안내\ndv.header(4, \"⚙️ 커스터마이징 가이드\");\ndv.paragraph(\"📝 **프로퍼티 편집**: 파일명을 클릭해서 노트를 열고 Metadata Menu로 수정하세요!\");\ndv.paragraph(\"⚙️ **설정 변경**: 코드 상단의 설정 영역에서 그룹핑, 정렬, 컬럼 등을 자유롭게 수정할 수 있습니다!\");\n```",
        "file_path": "/Users/joonpark/Documents/Obsidian/Obsidian/Models - LoRa.md",
        "summary": "이 코드는 Obsidian DataviewJS를 사용하여 특정 폴더(`Clippings/Models`)의 파일들을 태그(`lora`)를 기준으로 그룹화하고, 별점, 중요도, 좋아요 순으로 정렬하여 테이블 형태로 보여주는 스크립트입니다.  사용자는 상단의 설정 영역에서 폴더 경로, 필터링 조건, 속성 정의, 그룹핑 방식, 정렬 기준, 테이블 컬럼 및 스타일 등을 자유롭게 변경하여 기능을 커스터마이징할 수 있습니다.  각 파일의 제목, 이미지, 별점, 태그, 중요도, 좋아요, 설명 등을 포함하는 테이블이 생성되며, 이미지 표시, 그룹별 개수 표시, 설명 길이 제한 등의 추가적인 표시 설정도 가능합니다.\n"
    },
    {
        "title": "PromptHero_advanced",
        "url": "file:///Users/joonpark/Documents/Obsidian/Obsidian/PromptHero_advanced.md",
        "source": "obsidian",
        "body": "```dataviewjs\n// ==================== 설정 영역 ====================\n// 이 부분만 수정하면 모든 기능을 커스터마이징할 수 있습니다!\n\n// 📁 폴더 설정\nconst FOLDER_CONFIG = {\n    path: \"Clippings/Prompts\",           // 대상 폴더\n    filterBy: \"author\",          // 필터링할 속성\n    filterValue: \"prompthero\"    // 필터링 값 (소문자로 변환됨)\n};\n\n// 🏷️ 속성 정의 및 한글명 매핑\nconst PROPERTIES = {\n    // 기본 속성들\n    title: { ko: \"제목\", type: \"text\", icon: \"📄\" },\n    description: { ko: \"설명\", type: \"text\", icon: \"📝\" },\n    author: { ko: \"작성자\", type: \"text\", icon: \"👤\" },\n    tags: { ko: \"태그\", type: \"list\", icon: \"🏷️\" },\n    \n    // 평가 관련\n    rating: { ko: \"별점\", type: \"number\", icon: \"⭐\", min: 1, max: 5 },\n    likes: { ko: \"좋아요\", type: \"number\", icon: \"❤️\" },\n    priority: { ko: \"중요도\", type: \"select\", icon: \"🚦\", \n        options: {\n            'High': '🔴 높음', 'Medium': '🟡 보통', 'Low': '🟢 낮음',\n            '높음': '🔴 높음', '중간': '🟡 보통', '낮음': '🟢 낮음'\n        }\n    },\n    \n    // 상태 관련\n    status: { ko: \"상태\", type: \"select\", icon: \"📋\",\n        options: {\n            'TODO': '📋 할 일', 'IN_PROGRESS': '⚡ 진행중', 'DONE': '✅ 완료',\n            'REVIEW': '👀 검토중', 'ARCHIVED': '📦 보관됨'\n        }\n    },\n    \n    // 날짜 관련\n    created: { ko: \"생성일\", type: \"date\", icon: \"📅\" },\n    modified: { ko: \"수정일\", type: \"date\", icon: \"🔄\" },\n    \n    // 커스텀 속성들 (필요에 따라 추가)\n    category: { ko: \"카테고리\", type: \"text\", icon: \"📂\" },\n    difficulty: { ko: \"난이도\", type: \"select\", icon: \"📊\",\n        options: {\n            'Easy': '🟢 쉬움', 'Medium': '🟡 보통', 'Hard': '🔴 어려움'\n        }\n    }\n};\n\n// 🎯 그룹핑 설정\nconst GROUPING_CONFIG = {\n    // 사용할 그룹핑 방식 선택 (하나만 활성화)\n    active: \"tags\",  // rating, priority, tags, author, status, created, category 등\n    \n    // 그룹별 특별 설정\n    settings: {\n        tags: {\n            allowMultiple: true,    // 한 파일이 여러 그룹에 속할 수 있음\n            emptyLabel: \"태그 없음\"\n        },\n        rating: {\n            sortOrder: \"desc\",      // desc: 높은 점수부터, asc: 낮은 점수부터\n            emptyLabel: \"평점 없음\"\n        },\n        created: {\n            format: \"yyyy-MM\",      // 날짜 포맷 (년-월)\n            emptyLabel: \"날짜 없음\"\n        }\n    }\n};\n\n// 📊 정렬 설정 (그룹 내에서의 정렬)\nconst SORTING_CONFIG = [\n    { field: \"rating\", order: \"desc\" },     // 1순위: 별점 높은 순\n    { field: \"priority\", order: \"asc\" },    // 2순위: 중요도 높은 순\n    { field: \"likes\", order: \"desc\" },      // 3순위: 좋아요 많은 순\n    { field: \"title\", order: \"asc\" }        // 4순위: 제목 알파벳 순\n];\n\n// 🗂️ 테이블 컬럼 설정 (순서 중요! 왼쪽부터 표시됨)\nconst TABLE_COLUMNS = [\n    { field: \"title\", width: \"200px\" },      // 파일 이름\n    { field: \"image\", width: \"180px\" },      // 첫 번째 이미지\n    { field: \"rating\", width: \"120px\" },     // 별점  \n    { field: \"tags\", width: \"150px\" },       // 태그\n    { field: \"priority\", width: \"100px\" },   // 중요도\n    { field: \"likes\", width: \"80px\" },       // 좋아요\n    { field: \"description\", width: \"300px\" } // 설명\n];\n\n// 🎨 테이블 스타일 설정\nconst TABLE_STYLE = {\n    // 컬럼 너비 조절\n    enableColumnWidth: true,    // 컬럼 너비 적용 여부\n    \n    // 테이블 전체 설정\n    tableWidth: \"100%\",         // 테이블 전체 너비 (100%, 1200px 등)\n    maxTableHeight: \"600px\",    // 테이블 최대 높이 (스크롤)\n    \n    // 셀 스타일\n    cellPadding: \"8px\",         // 셀 안쪽 여백\n    cellAlignment: {            // 컬럼별 정렬\n        \"title\": \"left\",\n        \"image\": \"center\",\n        \"rating\": \"center\", \n        \"tags\": \"left\",\n        \"priority\": \"center\",\n        \"likes\": \"center\",\n        \"description\": \"left\"\n    },\n    \n    // 텍스트 설정\n    fontSize: \"14px\",           // 글자 크기\n    lineHeight: \"1.4\",          // 줄 간격\n    \n    // 색상 테마\n    headerBgColor: \"#f0f0f0\",   // 헤더 배경색\n    evenRowBgColor: \"#f9f9f9\",  // 짝수 행 배경색\n    hoverColor: \"#e6f3ff\"       // 마우스 오버 색상\n};\n\n// 🎨 표시 설정\nconst DISPLAY_CONFIG = {\n    showStats: true,           // 전체 통계 표시\n    showGroupCount: true,      // 그룹별 파일 수 표시\n    showImages: true,          // 이미지 표시\n    imageSize: 150,           // 이미지 크기\n    showEmptyGroups: false,   // 빈 그룹 표시 여부\n    maxDescriptionLength: 100 // 설명 최대 길이\n};\n\n// ==================== 메인 로직 ====================\n// 파일 선택\nconst files = dv.pages(`\"${FOLDER_CONFIG.path}\"`)\n    .where(p => {\n        if (!FOLDER_CONFIG.filterBy || !FOLDER_CONFIG.filterValue) return true;\n        \n        const filterField = p[FOLDER_CONFIG.filterBy];\n        if (!filterField) return false;\n        \n        const filterString = Array.isArray(filterField)\n            ? filterField.map(item => (item.path || item)).join(' ')\n            : String(filterField);\n        return filterString.toLowerCase().includes(FOLDER_CONFIG.filterValue.toLowerCase());\n    });\n\n// 속성 값 가져오기 함수\nconst getPropertyValue = (page, propName) => {\n    const prop = PROPERTIES[propName];\n    const value = page[propName];\n    \n    if (!value && propName === \"title\") return page.file?.name || \"제목 없음\";\n    if (!value && propName === \"created\") return page.file?.cday;\n    if (!value && propName === \"modified\") return page.file?.mday;\n    \n    return value;\n};\n\n// 그룹 키 생성 함수\nconst getGroupKey = (page, groupField) => {\n    const prop = PROPERTIES[groupField];\n    const value = getPropertyValue(page, groupField);\n    const settings = GROUPING_CONFIG.settings[groupField] || {};\n    \n    if (!value || (Array.isArray(value) && value.length === 0)) {\n        return settings.emptyLabel || `${prop?.ko || groupField} 없음`;\n    }\n    \n    // 태그는 배열로 반환 (여러 그룹에 속할 수 있음)\n    if (groupField === \"tags\") {\n        return Array.isArray(value) ? value : [value];\n    }\n    \n    // 선택형 속성은 한글명으로 변환\n    if (prop?.type === \"select\" && prop.options && prop.options[value]) {\n        return prop.options[value];\n    }\n    \n    // 날짜 포맷팅\n    if (prop?.type === \"date\" && value && settings.format) {\n        return `${prop.icon} ${value.toFormat(settings.format)}`;\n    }\n    \n    // 기본 포맷\n    return `${prop?.icon || \"\"} ${value}`.trim();\n};\n\n// 그룹핑 실행\nlet groupedPages;\nconst groupField = GROUPING_CONFIG.active;\nconst groupSettings = GROUPING_CONFIG.settings[groupField] || {};\n\nif (groupSettings.allowMultiple) {\n    // 여러 그룹에 속할 수 있는 경우 (예: tags)\n    groupedPages = files\n        .flatMap(p => {\n            const groups = getGroupKey(p, groupField);\n            const groupArray = Array.isArray(groups) ? groups : [groups];\n            return groupArray.map(group => ({ group: group, page: p }));\n        })\n        .groupBy(item => item.group);\n} else {\n    // 하나의 그룹에만 속하는 경우\n    groupedPages = files\n        .map(p => ({ group: getGroupKey(p, groupField), page: p }))\n        .groupBy(item => item.group);\n}\n\n// 정렬 함수\nconst sortPages = (pages) => {\n    return Array.from(pages).sort((a, b) => {\n        try {\n            const pA = groupSettings.allowMultiple ? a?.page : a?.page;\n            const pB = groupSettings.allowMultiple ? b?.page : b?.page;\n            \n            if (!pA || !pB) return pA ? -1 : pB ? 1 : 0;\n            \n            // 설정된 정렬 기준에 따라 순차적으로 정렬\n            for (let sortConfig of SORTING_CONFIG) {\n                const fieldA = getPropertyValue(pA, sortConfig.field);\n                const fieldB = getPropertyValue(pB, sortConfig.field);\n                \n                // 숫자 타입 처리\n                if (PROPERTIES[sortConfig.field]?.type === \"number\") {\n                    const numA = Number(fieldA) || 0;\n                    const numB = Number(fieldB) || 0;\n                    if (numA !== numB) {\n                        return sortConfig.order === \"desc\" ? numB - numA : numA - numB;\n                    }\n                }\n                \n                // 선택형 타입 처리 (우선순위 등)\n                else if (PROPERTIES[sortConfig.field]?.type === \"select\") {\n                    const prop = PROPERTIES[sortConfig.field];\n                    const orderA = Object.keys(prop.options || {}).indexOf(fieldA);\n                    const orderB = Object.keys(prop.options || {}).indexOf(fieldB);\n                    if (orderA !== orderB) {\n                        return sortConfig.order === \"desc\" ? orderB - orderA : orderA - orderB;\n                    }\n                }\n                \n                // 문자열 타입 처리\n                else {\n                    const strA = String(fieldA || '');\n                    const strB = String(fieldB || '');\n                    const comparison = strA.localeCompare(strB);\n                    if (comparison !== 0) {\n                        return sortConfig.order === \"desc\" ? -comparison : comparison;\n                    }\n                }\n            }\n            \n            return 0;\n        } catch (error) {\n            console.error(\"정렬 중 오류:\", error);\n            return 0;\n        }\n    });\n};\n\n// 그룹 정렬\nconst sortedGroups = Array.from(groupedPages)\n    .sort((a, b) => {\n        // 그룹 자체의 정렬 로직\n        const prop = PROPERTIES[groupField];\n        if (prop?.type === \"number\") {\n            const numA = parseFloat(a.key.replace(/[^\\d.-]/g, '')) || 0;\n            const numB = parseFloat(b.key.replace(/[^\\d.-]/g, '')) || 0;\n            return numB - numA; // 숫자는 큰 것부터\n        }\n        return a.key.localeCompare(b.key); // 문자는 알파벳 순\n    });\n\n// 통계 출력\nif (DISPLAY_CONFIG.showStats) {\n    const propInfo = PROPERTIES[groupField];\n    dv.header(2, `📊 ${propInfo?.ko || groupField}별 통계`);\n    dv.paragraph(`총 **${files.length}개** 파일이 **${sortedGroups.length}개** 그룹으로 분류되었습니다.`);\n}\n\n// 각 그룹 처리\nfor (let group of sortedGroups) {\n    if (!DISPLAY_CONFIG.showEmptyGroups && group.rows.length === 0) continue;\n    \n    // 그룹 헤더\n    const countText = DISPLAY_CONFIG.showGroupCount ? ` (${group.rows.length}개)` : '';\n    dv.header(3, `${group.key}${countText}`);\n    \n    // 파일들 정렬\n    const sortedFiles = sortPages(group.rows);\n    \n    // 테이블 데이터 준비\n    let tableRows = [];\n    for (let item of sortedFiles) {\n        const file = groupSettings.allowMultiple ? item?.page : item?.page;\n        if (!file) continue;\n        \n        let row = [];\n        \n        for (let colConfig of TABLE_COLUMNS) {\n            const colName = typeof colConfig === 'string' ? colConfig : colConfig.field;\n            if (colName === \"image\") {\n                // 이미지 처리\n                if (DISPLAY_CONFIG.showImages) {\n                    let imagePath = \"이미지 없음\";\n                    try {\n                        if (file.file?.path) {\n                            const fileContent = await dv.io.load(file.file.path);\n                            const imageMatch = fileContent.match(/!\\[.*?\\]\\((.*?)\\)|!\\[.*?\\]\\<\\s*(.*?)\\s*\\>/);\n                            if (imageMatch) {\n                                const extractedPath = imageMatch[1] || imageMatch[2];\n                                imagePath = `![](${extractedPath}|${DISPLAY_CONFIG.imageSize})`;\n                            }\n                        }\n                    } catch (e) {\n                        imagePath = \"이미지 로드 오류\";\n                    }\n                    row.push(imagePath);\n                }\n            } else if (colName === \"title\") {\n                // 파일명과 편집 버튼을 함께 표시\n                const fileLink = file.file?.link || \"링크 없음\";\n                row.push(fileLink);\n            } else {\n                const prop = PROPERTIES[colName];\n                let value = getPropertyValue(file, colName);\n                \n                // 값 포맷팅\n                if (value) {\n                    if (prop?.type === \"select\" && prop.options && prop.options[value]) {\n                        value = prop.options[value];\n                    } else if (colName === \"rating\") {\n                        // 별점을 노란색 채운 별과 빈 별로 시각적으로 표시\n                        const filledStars = \"⭐\".repeat(value);\n                        const emptyStars = \"☆\".repeat(5 - value);\n                        value = `${filledStars}${emptyStars} ${value}`;\n                    } else if (prop?.type === \"number\" && prop?.icon) {\n                        value = `${prop.icon} ${value}`;\n                    } else if (colName === \"description\" && value.length > DISPLAY_CONFIG.maxDescriptionLength) {\n                        value = value.substring(0, DISPLAY_CONFIG.maxDescriptionLength) + \"...\";\n                    } else if (Array.isArray(value)) {\n                        value = value.join(\", \");\n                    }\n                }\n                \n                row.push(value ?? \"N/A\");\n            }\n        }\n        \n        tableRows.push(row);\n    }\n    \n    // 테이블 헤더 생성\n    const headers = TABLE_COLUMNS.map(col => {\n        const colName = typeof col === 'string' ? col : col.field;\n        if (colName === \"image\") return \"이미지\";\n        if (colName === \"title\") return \"파일 이름\";\n        return PROPERTIES[colName]?.ko || colName;\n    });\n    \n    // CSS 스타일 적용\n    let tableStyle = \"\";\n    if (TABLE_STYLE.enableColumnWidth) {\n        tableStyle = `<style>\n            .dataview-table {\n                width: ${TABLE_STYLE.tableWidth};\n                max-height: ${TABLE_STYLE.maxTableHeight};\n                overflow-y: auto;\n                font-size: ${TABLE_STYLE.fontSize};\n                line-height: ${TABLE_STYLE.lineHeight};\n            }\n            \n            .dataview-table table {\n                width: 100%;\n                border-collapse: collapse;\n            }\n            \n            .dataview-table th {\n                background-color: ${TABLE_STYLE.headerBgColor};\n                padding: ${TABLE_STYLE.cellPadding};\n                font-weight: bold;\n                border: 1px solid #ddd;\n                position: sticky;\n                top: 0;\n                z-index: 10;\n            }\n            \n            .dataview-table td {\n                padding: ${TABLE_STYLE.cellPadding};\n                border: 1px solid #ddd;\n                vertical-align: top;\n            }\n            \n            .dataview-table tbody tr:nth-child(even) {\n                background-color: ${TABLE_STYLE.evenRowBgColor};\n            }\n            \n            .dataview-table tbody tr:hover {\n                background-color: ${TABLE_STYLE.hoverColor};\n            }\n            \n            ${TABLE_COLUMNS.map((col, index) => {\n                const colName = typeof col === 'string' ? col : col.field;\n                const width = typeof col === 'object' ? col.width : 'auto';\n                const alignment = TABLE_STYLE.cellAlignment[colName] || 'left';\n                return `\n                .dataview-table th:nth-child(${index + 1}),\n                .dataview-table td:nth-child(${index + 1}) {\n                    width: ${width};\n                    text-align: ${alignment};\n                    ${colName === 'description' ? 'word-wrap: break-word; max-width: 0;' : ''}\n                }`;\n            }).join('')}\n        </style>`;\n        \n        // 스타일을 한 번만 적용\n        if (group === sortedGroups[0]) {\n            dv.paragraph(tableStyle);\n        }\n    }\n    \n    // 테이블 출력 (CSS 클래스 적용)\n    if (tableRows.length > 0) {\n        dv.el(\"div\", \"\", { cls: \"dataview-table\" });\n        dv.table(headers, tableRows);\n    }\n}\n\n// 설정 안내\ndv.header(4, \"⚙️ 커스터마이징 가이드\");\ndv.paragraph(\"📝 **프로퍼티 편집**: 파일명을 클릭해서 노트를 열고 Metadata Menu로 수정하세요!\");\ndv.paragraph(\"⚙️ **설정 변경**: 코드 상단의 설정 영역에서 그룹핑, 정렬, 컬럼 등을 자유롭게 수정할 수 있습니다!\");\n```",
        "file_path": "/Users/joonpark/Documents/Obsidian/Obsidian/PromptHero_advanced.md",
        "summary": "이 코드는 Obsidian DataviewJS 플러그인을 이용하여, 특정 폴더의 노트들을 사용자 정의 속성(제목, 설명, 태그, 별점 등)에 따라 그룹화하고, 정렬하여 테이블 형태로 보여주는 스크립트입니다.  사용자는 폴더 경로, 필터링 조건, 속성 정의, 그룹핑 방식, 정렬 기준, 테이블 컬럼 및 스타일 등을 코드 상단의 설정 영역에서 자유롭게 변경하여 커스터마이징할 수 있습니다.  결과는 사용자 지정된 속성과 스타일을 반영한 정렬된 데이터 테이블로 출력됩니다.\n"
    },
    {
        "title": "250529 Stable diffusion",
        "url": "file:///Users/joonpark/Documents/Obsidian/Obsidian/250529 Stable diffusion.md",
        "source": "obsidian",
        "body": "이제 조사한 정보를 바탕으로 체계적으로 정리해드리겠습니다!\n\n# Diffusion 모델 카테고리별 완전 가이드\n\n## 🎯 1. 실사 (Realistic) 모델\n\n### 🏆 **추천 모델**\n\n#### **Realistic Vision v5.1/v6.0**\n- **특징**: SD 1.5 기반의 가장 안정적인 실사 모델\n- **장점**: 높은 품질, 안정적인 출력, 광범위한 호환성\n- **이미지 사이즈**: 512×512 (기본), 768×768 (최적화됨)\n- **CFG Scale**: 7-12\n- **추천 샘플러**: DPM++ 2M Karras, Euler a\n- **스텝**: 20-30\n\n**프롬프트 예시**:\n```\nmasterpiece, best quality, ultra detailed, 8k, photorealistic, portrait of beautiful woman, natural lighting, soft shadows, detailed skin texture, professional photography\nNegative: ugly, blurry, low quality, distorted, deformed, bad anatomy\n```\n\n#### **Juggernaut XL v9**\n- **특징**: SDXL 기반의 고품질 실사 모델\n- **장점**: 뛰어난 디테일, 사진 같은 품질\n- **이미지 사이즈**: 1024×1024 (기본), 1152×896, 896×1152\n- **CFG Scale**: 5-8\n- **추천 샘플러**: DPM++ 2M SDE Karras\n- **스텝**: 25-35\n\n#### **majicMIX Realistic v7**\n- **특징**: 아시아인 얼굴에 특화된 실사 모델\n- **장점**: 자연스러운 아시아인 특징 구현\n- **호환성**: SD 1.5 기반\n- **특별 주의사항**: NSFW 콘텐츠 생성 가능성\n\n#### **epicRealism v5**\n- **특징**: 높은 디테일과 자연스러운 조명\n- **장점**: 간단한 프롬프트로도 고품질 결과\n- **VAE**: 내장된 커스텀 VAE로 색상 정확도 향상\n\n## 🎨 2. 2.5D 모델\n\n### 🏆 **추천 모델**\n\n#### **Dreamshaper v8**\n- **특징**: 실사와 애니메이션의 균형잡힌 스타일\n- **장점**: 다양한 스타일 지원, 안정적인 출력\n- **이미지 사이즈**: 512×512, 768×768\n- **CFG Scale**: 7-11\n- **특별 기능**: 최소한의 프롬프트로도 우수한 결과\n\n**프롬프트 예시**:\n```\nmasterpiece, best quality, 1girl, detailed face, beautiful eyes, soft lighting, semi-realistic, detailed background\nNegative: low quality, blurry, bad anatomy, distorted face\n```\n\n#### **Perfect World v6**\n- **특징**: 실사와 애니메이션의 완벽한 균형\n- **장점**: 아름다운 실사 얼굴과 애니메이션 스타일 조합\n- **용도**: 캐릭터 일러스트, 컨셉 아트\n\n#### **GhostMix v2.0**\n- **특징**: 2.5D 스타일의 최강 모델 중 하나\n- **장점**: 복잡한 일러스트와 현실적 요소의 조화\n- **베이킹된 VAE**: 별도 VAE 불필요\n\n## 🎌 3. 2D (애니메이션) 모델\n\n### 🏆 **추천 모델**\n\n#### **Pony Diffusion V6 XL** ⭐\n- **특징**: SDXL 기반의 현재 최고 애니메이션 모델\n- **장점**: 뛰어난 해부학적 이해, 복잡한 포즈 구현\n- **이미지 사이즈**: 1024×1024, 1152×896, 896×1152\n- **CFG Scale**: 5-7\n- **특별 태그 시스템**: 댄부루 태그 체계 사용\n\n**프롬프트 예시**:\n```\nscore_9, score_8_up, score_7_up, 1girl, detailed face, beautiful anime eyes, colorful hair, dynamic pose, detailed background\nNegative: score_4, score_3, score_2, score_1, low quality, blurry\n```\n\n#### **Animagine XL v4.0**\n- **특징**: 애니메이션 전용 SDXL 모델\n- **장점**: 깨끗한 애니메이션 스타일, 캐릭터 일관성\n- **데이터셋**: 210만 장의 애니메이션 이미지로 훈련\n\n#### **Counterfeit v3.0**\n- **특징**: 고품질 애니메이션 스타일\n- **장점**: 근거리부터 원거리까지 다양한 샷 지원\n- **SD 1.5 기반**: 안정적이고 널리 지원됨\n\n#### **MeinaMix v11**\n- **특징**: 최소한의 프롬프트로 고품질 애니메이션\n- **장점**: 초보자 친화적, 일관된 스타일\n\n## ⚙️ 4. 모델별 주의사항 및 호환성\n\n### **SD 1.5 vs SDXL vs Flux 비교**\n\n| 특징 | SD 1.5 | SDXL | Flux |\n|------|--------|------|------|\n| 기본 해상도 | 512×512 | 1024×1024 | 1024×1024 |\n| 파라미터 수 | 860M | 3.5B | 12B |\n| VRAM 요구량 | 4GB+ | 8GB+ | 12GB+ |\n| 속도 | 빠름 | 중간 | 느림 |\n| 품질 | 양호 | 우수 | 최고 |\n\n### **해상도 권장사항**\n\n#### **SD 1.5 모델**\n- **최적 해상도**: 512×512\n- **지원 해상도**: 768×768 (일부 파인튠 모델)\n- **주의사항**: 512×512을 벗어나면 품질 저하 가능\n\n#### **SDXL 모델**\n- **최적 해상도**: 1024×1024\n- **권장 비율들**:\n  - 1024×1024 (1:1)\n  - 1152×896 (4:3)\n  - 896×1152 (3:4)\n  - 1216×832 (3:2)\n  - 832×1216 (2:3)\n\n### **샘플러 및 스케줄러 권장사항**\n\n#### **SD 1.5 모델**\n- **추천 샘플러**: DPM++ 2M Karras, Euler a, DDIM\n- **스텝**: 20-30\n- **CFG Scale**: 7-12\n\n#### **SDXL 모델**\n- **추천 샘플러**: DPM++ 2M SDE Karras, Euler a\n- **스텝**: 25-35\n- **CFG Scale**: 5-8 (낮은 값 권장)\n\n## 🔧 5. 실용적인 설정 가이드\n\n### **범용 네거티브 프롬프트**\n\n```\n# SD 1.5용\nugly, blurry, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username\n\n# SDXL용 (더 간단하게)\nlow quality, blurry, bad anatomy, distorted, deformed\n\n# Pony Diffusion용\nscore_4, score_3, score_2, score_1, low quality, blurry, bad anatomy\n```\n\n### **모델별 특별 설정**\n\n#### **Pony Diffusion XL**\n- **필수 포함**: `score_9, score_8_up, score_7_up`\n- **네거티브**: `score_4, score_3, score_2, score_1`\n- **특징**: 댄부루 태그 체계 사용 권장\n\n#### **WAI-NSFW-illustrious-SDXL**\n- **NSFW 필터링**: 네거티브에 \"nsfw\" 추가 필요\n- **프리프롬프트**: \"masterpiece, best quality, amazing quality\"\n\n## 📋 6. 용도별 최종 추천\n\n### **초보자용**\n1. **실사**: Realistic Vision v5.1\n2. **2.5D**: Dreamshaper v8  \n3. **2D**: MeinaMix v11\n\n### **고급 사용자용**\n1. **실사**: Juggernaut XL v9\n2. **2.5D**: GhostMix v2.0\n3. **2D**: Pony Diffusion V6 XL\n\n### **NSFW 콘텐츠용**\n1. **hassaku XL (Pony)**\n2. **MeinaHentai v4**\n3. **WAI-NSFW-illustrious-SDXL**\n\n### **아시아인 특화**\n1. **majicMIX Realistic v7**\n2. **ChilloutMix** (현재 다운로드 제한)\n\n이 가이드를 참고하여 목적에 맞는 모델을 선택하고 적절한 설정으로 최고의 결과를 얻으시기 바랍니다!",
        "file_path": "/Users/joonpark/Documents/Obsidian/Obsidian/250529 Stable diffusion.md",
        "summary": "이 글은 Diffusion 모델을 실사, 2.5D, 2D 애니메이션으로 분류하여 각 카테고리별 추천 모델과 설정 가이드를 제공한다.  초보자와 고급 사용자를 위한 모델 추천과 더불어 SD 1.5, SDXL, Flux 모델의 비교, 해상도 및 샘플러 권장 사항, 그리고  NSFW 콘텐츠 및 아시아인 특화 모델까지 다양한 정보를 담고 있다.  최적의 결과를 얻기 위한 프롬프트 예시와 네거티브 프롬프트, 그리고 모델별 특별 설정까지 상세히 설명하여 사용자의 편의성을 높였다.\n"
    },
    {
        "title": "Diffusion Models",
        "url": "file:///Users/joonpark/Documents/Obsidian/Obsidian/Diffusion Models.md",
        "source": "obsidian",
        "body": "```dataviewjs\n// ==================== 설정 영역 ====================\n// 이 부분만 수정하면 모든 기능을 커스터마이징할 수 있습니다!\n\n// 📁 폴더 설정\nconst FOLDER_CONFIG = {\n    path: \"Clippings/Models\",           // 대상 폴더\n    filterBy: \"tags\",          // 필터링할 속성\n    filterValue: \"models\",    // 필터링 값 (소문자로 변환됨)\n    excludeValue: \"lora\"\n};\n\n// 🏷️ 속성 정의 및 한글명 매핑\nconst PROPERTIES = {\n    // 기본 속성들\n    title: { ko: \"제목\", type: \"text\", icon: \"📄\" },\n    description: { ko: \"설명\", type: \"text\", icon: \"📝\" },\n    author: { ko: \"작성자\", type: \"text\", icon: \"👤\" },\n    tags: { ko: \"태그\", type: \"list\", icon: \"🏷️\" },\n    \n    // 평가 관련\n    rating: { ko: \"별점\", type: \"number\", icon: \"⭐\", min: 1, max: 5 },\n    likes: { ko: \"좋아요\", type: \"number\", icon: \"❤️\" },\n    priority: { ko: \"중요도\", type: \"select\", icon: \"🚦\", \n        options: {\n            'High': '🔴 높음', 'Medium': '🟡 보통', 'Low': '🟢 낮음',\n            '높음': '🔴 높음', '중간': '🟡 보통', '낮음': '🟢 낮음'\n        }\n    },\n    \n    // 상태 관련\n    status: { ko: \"상태\", type: \"select\", icon: \"📋\",\n        options: {\n            'TODO': '📋 할 일', 'IN_PROGRESS': '⚡ 진행중', 'DONE': '✅ 완료',\n            'REVIEW': '👀 검토중', 'ARCHIVED': '📦 보관됨'\n        }\n    },\n    \n    // 날짜 관련\n    created: { ko: \"생성일\", type: \"date\", icon: \"📅\" },\n    modified: { ko: \"수정일\", type: \"date\", icon: \"🔄\" },\n    \n    // 커스텀 속성들 (필요에 따라 추가)\n    category: { ko: \"카테고리\", type: \"text\", icon: \"📂\" },\n    difficulty: { ko: \"난이도\", type: \"select\", icon: \"📊\",\n        options: {\n            'Easy': '🟢 쉬움', 'Medium': '🟡 보통', 'Hard': '🔴 어려움'\n        }\n    }\n};\n\n// 🎯 그룹핑 설정\nconst GROUPING_CONFIG = {\n    // 사용할 그룹핑 방식 선택 (하나만 활성화)\n    active: \"tags\",  // rating, priority, tags, author, status, created, category 등\n    \n    // 그룹별 특별 설정\n    settings: {\n        tags: {\n            allowMultiple: true,    // 한 파일이 여러 그룹에 속할 수 있음\n            emptyLabel: \"태그 없음\"\n        },\n        rating: {\n            sortOrder: \"desc\",      // desc: 높은 점수부터, asc: 낮은 점수부터\n            emptyLabel: \"평점 없음\"\n        },\n        created: {\n            format: \"yyyy-MM\",      // 날짜 포맷 (년-월)\n            emptyLabel: \"날짜 없음\"\n        }\n    }\n};\n\n// 📊 정렬 설정 (그룹 내에서의 정렬)\nconst SORTING_CONFIG = [\n    { field: \"rating\", order: \"desc\" },     // 1순위: 별점 높은 순\n    { field: \"priority\", order: \"asc\" },    // 2순위: 중요도 높은 순\n    { field: \"likes\", order: \"desc\" },      // 3순위: 좋아요 많은 순\n    { field: \"title\", order: \"asc\" }        // 4순위: 제목 알파벳 순\n];\n\n// 🗂️ 테이블 컬럼 설정 (순서 중요! 왼쪽부터 표시됨)\nconst TABLE_COLUMNS = [\n    { field: \"title\", width: \"200px\" },      // 파일 이름\n    { field: \"image\", width: \"180px\" },      // 첫 번째 이미지\n    { field: \"rating\", width: \"120px\" },     // 별점  \n    { field: \"tags\", width: \"150px\" },       // 태그\n    { field: \"priority\", width: \"100px\" },   // 중요도\n    { field: \"likes\", width: \"80px\" },       // 좋아요\n    { field: \"description\", width: \"300px\" } // 설명\n];\n\n// 🎨 테이블 스타일 설정\nconst TABLE_STYLE = {\n    // 컬럼 너비 조절\n    enableColumnWidth: true,    // 컬럼 너비 적용 여부\n    \n    // 테이블 전체 설정\n    tableWidth: \"100%\",         // 테이블 전체 너비 (100%, 1200px 등)\n    maxTableHeight: \"600px\",    // 테이블 최대 높이 (스크롤)\n    \n    // 셀 스타일\n    cellPadding: \"8px\",         // 셀 안쪽 여백\n    cellAlignment: {            // 컬럼별 정렬\n        \"title\": \"left\",\n        \"image\": \"center\",\n        \"rating\": \"center\", \n        \"tags\": \"left\",\n        \"priority\": \"center\",\n        \"likes\": \"center\",\n        \"description\": \"left\"\n    },\n    \n    // 텍스트 설정\n    fontSize: \"14px\",           // 글자 크기\n    lineHeight: \"1.4\",          // 줄 간격\n    \n    // 색상 테마\n    headerBgColor: \"#f0f0f0\",   // 헤더 배경색\n    evenRowBgColor: \"#f9f9f9\",  // 짝수 행 배경색\n    hoverColor: \"#e6f3ff\"       // 마우스 오버 색상\n};\n\n// 🎨 표시 설정\nconst DISPLAY_CONFIG = {\n    showStats: true,           // 전체 통계 표시\n    showGroupCount: true,      // 그룹별 파일 수 표시\n    showImages: true,          // 이미지 표시\n    imageSize: 150,           // 이미지 크기\n    showEmptyGroups: false,   // 빈 그룹 표시 여부\n    maxDescriptionLength: 100 // 설명 최대 길이\n};\n\n// ==================== 메인 로직 ====================\n// 파일 선택\nconst files = dv.pages(`\"${FOLDER_CONFIG.path}\"`)\n    .where(p => {\n        if (!FOLDER_CONFIG.filterBy || !FOLDER_CONFIG.filterValue) return true;\n        \n        const filterField = p[FOLDER_CONFIG.filterBy];\n        if (!filterField) return false;\n        \n        const filterString = Array.isArray(filterField)\n            ? filterField.map(item => (item.path || item)).join(' ')\n            : String(filterField);\n        return filterString.toLowerCase().includes(FOLDER_CONFIG.filterValue.toLowerCase());\n    });\n\n// 속성 값 가져오기 함수\nconst getPropertyValue = (page, propName) => {\n    const prop = PROPERTIES[propName];\n    const value = page[propName];\n    \n    if (!value && propName === \"title\") return page.file?.name || \"제목 없음\";\n    if (!value && propName === \"created\") return page.file?.cday;\n    if (!value && propName === \"modified\") return page.file?.mday;\n    \n    return value;\n};\n\n// 그룹 키 생성 함수\nconst getGroupKey = (page, groupField) => {\n    const prop = PROPERTIES[groupField];\n    const value = getPropertyValue(page, groupField);\n    const settings = GROUPING_CONFIG.settings[groupField] || {};\n    \n    if (!value || (Array.isArray(value) && value.length === 0)) {\n        return settings.emptyLabel || `${prop?.ko || groupField} 없음`;\n    }\n    \n    // 태그는 배열로 반환 (여러 그룹에 속할 수 있음)\n    if (groupField === \"tags\") {\n        return Array.isArray(value) ? value : [value];\n    }\n    \n    // 선택형 속성은 한글명으로 변환\n    if (prop?.type === \"select\" && prop.options && prop.options[value]) {\n        return prop.options[value];\n    }\n    \n    // 날짜 포맷팅\n    if (prop?.type === \"date\" && value && settings.format) {\n        return `${prop.icon} ${value.toFormat(settings.format)}`;\n    }\n    \n    // 기본 포맷\n    return `${prop?.icon || \"\"} ${value}`.trim();\n};\n\n// 그룹핑 실행\nlet groupedPages;\nconst groupField = GROUPING_CONFIG.active;\nconst groupSettings = GROUPING_CONFIG.settings[groupField] || {};\n\nif (groupSettings.allowMultiple) {\n    // 여러 그룹에 속할 수 있는 경우 (예: tags)\n    groupedPages = files\n        .flatMap(p => {\n            const groups = getGroupKey(p, groupField);\n            const groupArray = Array.isArray(groups) ? groups : [groups];\n            return groupArray.map(group => ({ group: group, page: p }));\n        })\n        .groupBy(item => item.group);\n} else {\n    // 하나의 그룹에만 속하는 경우\n    groupedPages = files\n        .map(p => ({ group: getGroupKey(p, groupField), page: p }))\n        .groupBy(item => item.group);\n}\n\n// 정렬 함수\nconst sortPages = (pages) => {\n    return Array.from(pages).sort((a, b) => {\n        try {\n            const pA = groupSettings.allowMultiple ? a?.page : a?.page;\n            const pB = groupSettings.allowMultiple ? b?.page : b?.page;\n            \n            if (!pA || !pB) return pA ? -1 : pB ? 1 : 0;\n            \n            // 설정된 정렬 기준에 따라 순차적으로 정렬\n            for (let sortConfig of SORTING_CONFIG) {\n                const fieldA = getPropertyValue(pA, sortConfig.field);\n                const fieldB = getPropertyValue(pB, sortConfig.field);\n                \n                // 숫자 타입 처리\n                if (PROPERTIES[sortConfig.field]?.type === \"number\") {\n                    const numA = Number(fieldA) || 0;\n                    const numB = Number(fieldB) || 0;\n                    if (numA !== numB) {\n                        return sortConfig.order === \"desc\" ? numB - numA : numA - numB;\n                    }\n                }\n                \n                // 선택형 타입 처리 (우선순위 등)\n                else if (PROPERTIES[sortConfig.field]?.type === \"select\") {\n                    const prop = PROPERTIES[sortConfig.field];\n                    const orderA = Object.keys(prop.options || {}).indexOf(fieldA);\n                    const orderB = Object.keys(prop.options || {}).indexOf(fieldB);\n                    if (orderA !== orderB) {\n                        return sortConfig.order === \"desc\" ? orderB - orderA : orderA - orderB;\n                    }\n                }\n                \n                // 문자열 타입 처리\n                else {\n                    const strA = String(fieldA || '');\n                    const strB = String(fieldB || '');\n                    const comparison = strA.localeCompare(strB);\n                    if (comparison !== 0) {\n                        return sortConfig.order === \"desc\" ? -comparison : comparison;\n                    }\n                }\n            }\n            \n            return 0;\n        } catch (error) {\n            console.error(\"정렬 중 오류:\", error);\n            return 0;\n        }\n    });\n};\n\n// 그룹 정렬\nconst sortedGroups = Array.from(groupedPages)\n    .sort((a, b) => {\n        // 그룹 자체의 정렬 로직\n        const prop = PROPERTIES[groupField];\n        if (prop?.type === \"number\") {\n            const numA = parseFloat(a.key.replace(/[^\\d.-]/g, '')) || 0;\n            const numB = parseFloat(b.key.replace(/[^\\d.-]/g, '')) || 0;\n            return numB - numA; // 숫자는 큰 것부터\n        }\n        return a.key.localeCompare(b.key); // 문자는 알파벳 순\n    });\n\n// 통계 출력\nif (DISPLAY_CONFIG.showStats) {\n    const propInfo = PROPERTIES[groupField];\n    dv.header(2, `📊 ${propInfo?.ko || groupField}별 통계`);\n    dv.paragraph(`총 **${files.length}개** 파일이 **${sortedGroups.length}개** 그룹으로 분류되었습니다.`);\n}\n\n// 각 그룹 처리\nfor (let group of sortedGroups) {\n    if (!DISPLAY_CONFIG.showEmptyGroups && group.rows.length === 0) continue;\n    \n    // 그룹 헤더\n    const countText = DISPLAY_CONFIG.showGroupCount ? ` (${group.rows.length}개)` : '';\n    dv.header(3, `${group.key}${countText}`);\n    \n    // 파일들 정렬\n    const sortedFiles = sortPages(group.rows);\n    \n    // 테이블 데이터 준비\n    let tableRows = [];\n    for (let item of sortedFiles) {\n        const file = groupSettings.allowMultiple ? item?.page : item?.page;\n        if (!file) continue;\n        \n        let row = [];\n        \n        for (let colConfig of TABLE_COLUMNS) {\n            const colName = typeof colConfig === 'string' ? colConfig : colConfig.field;\n            if (colName === \"image\") {\n                // 이미지 처리\n                if (DISPLAY_CONFIG.showImages) {\n                    let imagePath = \"이미지 없음\";\n                    try {\n                        if (file.file?.path) {\n                            const fileContent = await dv.io.load(file.file.path);\n                            const imageMatch = fileContent.match(/!\\[.*?\\]\\((.*?)\\)|!\\[.*?\\]\\<\\s*(.*?)\\s*\\>/);\n                            if (imageMatch) {\n                                const extractedPath = imageMatch[1] || imageMatch[2];\n                                imagePath = `![](${extractedPath}|${DISPLAY_CONFIG.imageSize})`;\n                            }\n                        }\n                    } catch (e) {\n                        imagePath = \"이미지 로드 오류\";\n                    }\n                    row.push(imagePath);\n                }\n            } else if (colName === \"title\") {\n                // 파일명과 편집 버튼을 함께 표시\n                const fileLink = file.file?.link || \"링크 없음\";\n                row.push(fileLink);\n            } else {\n                const prop = PROPERTIES[colName];\n                let value = getPropertyValue(file, colName);\n                \n                // 값 포맷팅\n                if (value) {\n                    if (prop?.type === \"select\" && prop.options && prop.options[value]) {\n                        value = prop.options[value];\n                    } else if (colName === \"rating\") {\n                        // 별점을 노란색 채운 별과 빈 별로 시각적으로 표시\n                        const filledStars = \"⭐\".repeat(value);\n                        const emptyStars = \"☆\".repeat(5 - value);\n                        value = `${filledStars}${emptyStars} ${value}`;\n                    } else if (prop?.type === \"number\" && prop?.icon) {\n                        value = `${prop.icon} ${value}`;\n                    } else if (colName === \"description\" && value.length > DISPLAY_CONFIG.maxDescriptionLength) {\n                        value = value.substring(0, DISPLAY_CONFIG.maxDescriptionLength) + \"...\";\n                    } else if (Array.isArray(value)) {\n                        value = value.join(\", \");\n                    }\n                }\n                \n                row.push(value ?? \"N/A\");\n            }\n        }\n        \n        tableRows.push(row);\n    }\n    \n    // 테이블 헤더 생성\n    const headers = TABLE_COLUMNS.map(col => {\n        const colName = typeof col === 'string' ? col : col.field;\n        if (colName === \"image\") return \"이미지\";\n        if (colName === \"title\") return \"파일 이름\";\n        return PROPERTIES[colName]?.ko || colName;\n    });\n    \n    // CSS 스타일 적용\n    let tableStyle = \"\";\n    if (TABLE_STYLE.enableColumnWidth) {\n        tableStyle = `<style>\n            .dataview-table {\n                width: ${TABLE_STYLE.tableWidth};\n                max-height: ${TABLE_STYLE.maxTableHeight};\n                overflow-y: auto;\n                font-size: ${TABLE_STYLE.fontSize};\n                line-height: ${TABLE_STYLE.lineHeight};\n            }\n            \n            .dataview-table table {\n                width: 100%;\n                border-collapse: collapse;\n            }\n            \n            .dataview-table th {\n                background-color: ${TABLE_STYLE.headerBgColor};\n                padding: ${TABLE_STYLE.cellPadding};\n                font-weight: bold;\n                border: 1px solid #ddd;\n                position: sticky;\n                top: 0;\n                z-index: 10;\n            }\n            \n            .dataview-table td {\n                padding: ${TABLE_STYLE.cellPadding};\n                border: 1px solid #ddd;\n                vertical-align: top;\n            }\n            \n            .dataview-table tbody tr:nth-child(even) {\n                background-color: ${TABLE_STYLE.evenRowBgColor};\n            }\n            \n            .dataview-table tbody tr:hover {\n                background-color: ${TABLE_STYLE.hoverColor};\n            }\n            \n            ${TABLE_COLUMNS.map((col, index) => {\n                const colName = typeof col === 'string' ? col : col.field;\n                const width = typeof col === 'object' ? col.width : 'auto';\n                const alignment = TABLE_STYLE.cellAlignment[colName] || 'left';\n                return `\n                .dataview-table th:nth-child(${index + 1}),\n                .dataview-table td:nth-child(${index + 1}) {\n                    width: ${width};\n                    text-align: ${alignment};\n                    ${colName === 'description' ? 'word-wrap: break-word; max-width: 0;' : ''}\n                }`;\n            }).join('')}\n        </style>`;\n        \n        // 스타일을 한 번만 적용\n        if (group === sortedGroups[0]) {\n            dv.paragraph(tableStyle);\n        }\n    }\n    \n    // 테이블 출력 (CSS 클래스 적용)\n    if (tableRows.length > 0) {\n        dv.el(\"div\", \"\", { cls: \"dataview-table\" });\n        dv.table(headers, tableRows);\n    }\n}\n\n// 설정 안내\ndv.header(4, \"⚙️ 커스터마이징 가이드\");\ndv.paragraph(\"📝 **프로퍼티 편집**: 파일명을 클릭해서 노트를 열고 Metadata Menu로 수정하세요!\");\ndv.paragraph(\"⚙️ **설정 변경**: 코드 상단의 설정 영역에서 그룹핑, 정렬, 컬럼 등을 자유롭게 수정할 수 있습니다!\");\n```",
        "file_path": "/Users/joonpark/Documents/Obsidian/Obsidian/Diffusion Models.md",
        "summary": "이 코드는 Obsidian DataviewJS 플러그인을 사용하여 지정된 폴더 내의 노트들을 태그, 평점, 중요도 등의 속성에 따라 그룹화하고, 정렬하여 테이블 형태로 보여주는 스크립트입니다.  사용자는 코드 상단의 설정 영역에서 폴더 경로, 필터링 조건, 표시 속성, 정렬 기준 등을 자유롭게 변경하여 커스터마이징할 수 있습니다.  테이블은 사용자 정의된 컬럼과 스타일을 적용하여 보기 좋게 출력됩니다.\n"
    },
    {
        "title": "강제로 갈아탄 Obsidian - Dataview로 가계부 정리하기",
        "url": "file:///Users/joonpark/Documents/Obsidian/Obsidian/Clippings/강제로 갈아탄 Obsidian - Dataview로 가계부 정리하기.md",
        "source": "obsidian",
        "body": "---\ntitle: \"강제로 갈아탄 Obsidian - Dataview로 가계부 정리하기\"\nsource: \"https://velog.io/@a_in/obsidian-financial-ledger-with-dataview\"\nauthor:\npublished:\ncreated: 2025-04-25T00:00:00\ndescription: \"\bObsidian을 일상생활에서도 제대로 활용해봅시다!\"\ntags:\n  - \"clippings\"\ndate modified: 2025-04-25T23:55:25\n---\n[a\\_in.log](https://velog.io/@a_in/posts)\n\n노션을 잘 쓰고 있던 와중에 무료 블록을 다 사용해버렸다는 문구가 뜨며 저는 이제 Obsidian(이하 옵시디언)으로 갈아타게 되었습니다.\n\n![](https://velog.velcdn.com/images/a_in/post/b55fa435-ede2-42ee-987d-413fb5971c94/image.png)\n\n그동안 옵시디언을 주 노트앱으로 써보고 싶었지만 뭐언가 노션에서 쓰던 것처럼 마크다운만으로는 예쁘게 정리가 안되어서 미루고 미뤄왔는데요, 노션이 유료가 되버리면서(ㅠ) 옵시디언을 쓰기로 마음 먹었습니다. 이제부터 저의 것으로 만들어보려 합니다.\n\n## 메모앱, 근데 이제 플러그인을 곁들인..\n\n> *Obsidian is the private and flexible writing app that adapts to the way you think.*  \n> *[Obsidian.md](https://obsidian.md/)*\n\n[옵시디언](https://obsidian.md/) 은 노션과 같은 매모앱입니다. 노션과 다른점이 있다면, 훨씬 자유롭다는 것입니다. 테마, 폰트 등 내 마음대로 꾸밀 수 있고 템플릿 만들기, 데이터뷰 조회, 폴더 정렬 등 다양한 기능들을 플러그인 형태로 자유롭게 다운받아 사용할 수 있습니다.\n\n이번 글에선 노션에서 Database를 사용해 만든 가계부를 옵시디언의 Dataview로 만드는 방법을 소개해볼까합니다.\n\n직접 플러그인을 만들어 사용하고 싶지만 우선은 있는걸 활용해서 만들어봅시다!\n\n## Dataview\n\n저는 노션에서 표보기 형태로 가계부를 써왔습니다.  \n고정지출이 얼마나 있고, 합해서 얼마이고, 이체가 됐는지에 대한 여부 등등 돈을 애껴쓰기 위해 달마다 적어서 관리하고 있습니다.\n\n![노션 가계부 표 데이터베이스 활용](https://velog.velcdn.com/images/a_in/post/12a9f9b6-76db-437d-af63-cfaf78b780f0/image.png)\n\n대문자 P인 저에게는 요 기능만큼 잘 써지던 가계부 템플릿이 없었기에 옵시디언에서도 그동안 써오던 형식으로 만들어보려고합니다.  \n.  \n.  \n.  \n.  \n.\n\n엿보기!\n\n![옵시디언 Dataview 가계부](https://velog.velcdn.com/images/a_in/post/f3efe030-dbbd-4f5c-a0ca-d1735a283186/image.png)\n\n.  \n.  \n.  \n.  \n.\n\n## Dateview 플러그인\n\nDataview 라는 플러그인을 사용하였는데, 노션처럼 테이블에서 데이터를 직접 수정하는게 아니더라구요.  \n그래서 기존 템플릿대로 만드는 방법을 못찾나 생각하던 찰나 다시 생각해보니 노션도 어쨌든 각 항목마다 페이지가 있고 페이지의 property가 테이블의 열로 들어갑니다.\n\n그렇다면!  \n하나의 행에 해당하는 페이지를 직접 만들어서 테이블로 만들면 될 것 같습니다.\n\n## 테이블을 그리기 위한 페이지 생성\n\n- 우선 생활비, 고정지출, 저축 등등 항목들을 페이지로 만듭니다.  \n\t![가계부 항목 생성](https://velog.velcdn.com/images/a_in/post/9416ba93-bc09-49b0-b3d6-5b6fec731d4b/image.png)\n- 페이지에 property를 만듭니다. 저의 경우 소비 카테고리, 소비내역, 지출경로 등을 추가합니다.  \n\t![가계부 페이지 프로퍼티](https://velog.velcdn.com/images/a_in/post/336baeda-9c62-4a54-ade4-18e03828e88f/image.png)\n\n## 테이블 그리기\n\n테이블을 조회할 페이지를 만들고 테이블을 그리는 코드를 작성합니다.  \n제가 사용한것은 dataview의 자바스크립트 문법이며, 기본 문법은 이러합니다.\n\n```js\n\\`\\`\\`dataviewjs\nconst table = await dv.query(\\`\nTABLE WITHOUT ID \n  file.link as Name\n  cost as Cost\n  transfer as 이체\n  category as Category\n  card as Card\n  assigned as Assigned\n\nFROM \"02. Area/Money/2025/Feb\"\nSORT category desc\n\\`)\\`\\`\\`\n```\n- **dv.query** - dataview의 query 메소드로 테이블을 그릴 수 있음.\n- **TABLE** - 테이블 뷰를 쓸 때 사용하는 용어다. TABLE외에도 LIST 등이 있음.\n- **WITHOUT ID** - WITHOUT ID 없이 그린다면 파일이름과 링크가 걸려있는 FILE 열이 자동으로 생김. 이 열을 표시하고 싶지 않다면 WITHOUT ID를 추가 하면 되고, 다른 이름으로 표시하고 싶다면 file.link as Name으로 설정하면 됨.\n- **as** - property 이름을 추가해서 테이블 헤더에 원하는 이름으로 표시 할 수 있음. ex: `cost as Cost` 를 넣는다면 페이지에 cost property가 들어가고, 테이블 헤더에는 \"Cost\"라는 이름으로 표시됨.\n- **FROM** - 어느 폴더에서 페이지들을 가져올건지 경로를 기입\n- **SORT** - 정렬을 할 수 있습니다.\n1. Header와 Cell들을 집어 넣습니다.\n```js\nif ( table.successful ) {\n  dv.table(table.value.headers, table.value.values)\n} else {\n  dv.paragraph(\"~~~~\\n\" + table.error + \"\\n~~~~\")\n}\n```\n\n![가계부 테이블 뼈대](https://velog.velcdn.com/images/a_in/post/ce0ac3ab-2992-442c-a3f1-4bbe89fe9c87/image.png)\n\n## 꾸미기\n\n제가 필요한 가계부 정리 기능은 이게 전부이긴 합니다.  \n하지만 저는 이쁜게 최고이기 때문에 숫자도 천단위로 나누고, 카테고리도 칩으로 만들고 테이블도 테이블답게 꾸며보겠습니다.\n\n```js\n\\`\\`\\`dataviewjs\nconst query = QUERY_ARRAY.map((q) => \\`${q.dataKey} as ${q.name}\\`).join(', \\n')\nconst table = await dv.query(\\`\nTABLE WITHOUT ID\n  file.link as Name\n  cost as Cost\n  transfer as 이체\n  category as Category\n  card as Card\n  assigned as Assigned\n\nFROM \"02. Area/Money/2025/Feb\"\nSORT category desc\n\\`)\n\nif ( table.successful ) {\n  const sumOfCost = table.value.values.map(a => a[1]).reduce((tmp, curr) => tmp + curr, 0).toLocaleString() \n  const tableHeaders = table.value.headers.map((header) => {\n    return \\`<span style='margin:14px 0;font-weight:400; font-size: 16px; '>${header}</span>\\`\n  })\n  \n  table.value.values.push([\"<span style='float: right'><strong>Total:</strong></span>\", \\`<span style='font-weight:700;'>${sumOfCost}</span>\\`])\n  \n  const tableValues = table.value.values.map((value) => {\n    const cost = value[1]\n    const transferList = value[2]\n    const categoryList = value[3]\n    const cardList = value[4]\n  \n    const transferBGColor = {\n        자동이체: \"#134E6C\",\n        예정: \"#595959\",\n        완료: \"#1E7C19\"\n    }[transferList?.[0]]\n    const categoryBGColor = {\n        저축: \"#6E3D3D\",\n        생활비: \"#2B586D\",\n        고정지출: \"#7F6F1B\",\n        월별: \"#0F4622\"\n    }[categoryList?.[0]]\n    const cardBGColor = {\n        카카오뱅크: \"#7F6F1B\",\n        토스페이: \"#2B586D\",\n        신한K패스: \"#0F4622\",\n    }[cardList?.[0]]\n\n    const transferChip = getRoundChip({ list: transferList, bgColor: transferBGColor })\n    const categoryChip = getRectangleChip({ list: categoryList, bgColor: categoryBGColor })\n    const cardChip = getRectangleChip({ list: cardList, bgColor: cardBGColor })\n    \n    const filtered = [\n        \"<span style='color: black'>\" + value[0] + \"</span>\",\n        \\`<span style='float: right'>₩ ${value[1].toLocaleString()}</span>\\`,\n        !!transferList ? transferChip : \"\",\n        !!categoryList ? categoryChip : \"\",\n        !!cardList ? cardChip : \"\",\n        ...value.slice(5, value.length - 1),\n        value.at(-1) === false ? \"⬜️\" : value.at(-1) === true ? \"✅\" : \"\"\n    ]\n    return filtered\n  })\n\n  dv.table(tableHeaders, tableValues) \n\n} else {\n  dv.paragraph(\"~~~~\\n\" + table.error + \"\\n~~~~\")\n}\n\n// UTILS\nfunction getRoundChip ({ list, bgColor }) {\n    return \\`<span style='white-space: nowrap;background-color: ${bgColor}; padding: 4px 8px; border-radius: 12px;font-weight:600'>${list}</span>\\`\n}\nfunction getRectangleChip ({ list, bgColor }) {\n    return  \\`<span style='white-space: nowrap;background-color: ${bgColor}; padding: 2px 8px; border-radius: 4px;font-weight:600'>${list}</span>\\`\n}\\`\\`\\`\n```\n\ncost 값들에 toLocaleString 함수를 넣어 숫자를 보기 쉽게 만들었고, 고정지출 내역 합계도 넣어봤습니다.  \n카테고리별로 색깔이 다른 칩을 만들고, assigned 값에 따라 체크박스와 체크된 박스를 표시해줍니다.\n\n![](https://velog.velcdn.com/images/a_in/post/47f7fb7e-fa48-410f-869f-dadb17b9f637/image.png)\n\n오! 그럼 이제 조금은 보기 좋아졌죠?  \n저는 여기서 만족하지 못하고 테이블도 꾸며보려합니다. 테이블의 경우 dataview의 테이블을 직접 건들여야해서 css snippets를 추가해야합니다.\n\n## CSS 파일 추가\n\n`cmd + ,` > Appearance > CSS snippets 에서 토글을 열고 snippets 폴더안에 css 파일을 추가합니다.\n\n![CSS snippets css 파일 추가 경로](https://velog.velcdn.com/images/a_in/post/d395217d-a32b-4e36-a8e2-6972f5746eb4/image.png)\n\n```js\n.dataview.table-view-table {\n  // 테이블의 틀을 그립니다. border, border-radius 등등\n}\n\n.dataview.table-view-table tr {\n  // 테이블 안의 cell 프레임을 꾸밀 수 있습니다.\n}\n\n.dataview.table-view-table th {\n  // 테이블 안의 헤더를 꾸밀 수 있습니다.\n}\n\n.dataview.table-view-table td {\n  // 테이블 안의 cell을 꾸밀 수 있습니다.\n}\n```\n\n## 최종!\n\n![옵시디언 Dataview 가계부](https://velog.velcdn.com/images/a_in/post/f3efe030-dbbd-4f5c-a0ca-d1735a283186/image.png)\n\n---\n\n그럼 이제 해당 항목의 페이지로 가서 property를 수정하면, 테이블에서도 한눈에 볼 수 있게 됩니다!\n\n| Before | After |\n| --- | --- |\n| ![관리비 항목 이체 property 수정전](https://velog.velcdn.com/images/a_in/post/d094c653-03f4-419c-9b22-b36f701a48e2/image.png) | ![관리비 항목 이체 property 수정후](https://velog.velcdn.com/images/a_in/post/8015847f-2719-4f0d-8004-cf0cac3848b3/image.png) |\n\n#### 0개의 댓글\n\n#### 관련 채용 정보\n\n[![](https://static.wanted.co.kr/images/company/16782/e39dw1qlbwc3ijzc__400_400.jpg)](https://www.wanted.co.kr/wd/278604?client_id=KK03NuM8GrpMbYP7vrf8FxsI)\n\n[테크타카(ARGO)](https://www.wanted.co.kr/wd/278604?client_id=KK03NuM8GrpMbYP7vrf8FxsI)\n\n[Jr.Backend Engineer (Java / Spring)](https://www.wanted.co.kr/wd/278604?client_id=KK03NuM8GrpMbYP7vrf8FxsI)\n\n[테크타카에서 물류 자동화 플랫폼 ARGO를 개발하며, 데이터 효율성과 시스템 안정성을 위한 과제를 해결할 Jr. Backend Engineer를 찾습니다. Java와 Spring으로 유연한 시스템 디자인을 경험하고, 자율적 문화 속에서 역량을 마음껏 펼칠 기회를 제공합니다.](https://www.wanted.co.kr/wd/278604?client_id=KK03NuM8GrpMbYP7vrf8FxsI)\n\n[![](https://static.wanted.co.kr/images/company/52551/stztfcdvu65dt2bq__400_400.png)](https://www.wanted.co.kr/wd/275346?client_id=KK03NuM8GrpMbYP7vrf8FxsI)\n\n[디엘티파트너스](https://www.wanted.co.kr/wd/275346?client_id=KK03NuM8GrpMbYP7vrf8FxsI)\n\n[백엔드 개발자](https://www.wanted.co.kr/wd/275346?client_id=KK03NuM8GrpMbYP7vrf8FxsI)\n\n[DLT파트너스에서 '헬로우봇'과 '비트윈'과 같은 사랑받는 서비스를 개발하며, Java 기반 백엔드 시스템, API 서버 설계 및 실시간 채팅 모듈을 다룹니다. 다양한 IT 경험을 가진 팀과 함께 대량 데이터 처리를 통한 혁신적인 미래를 만들어갈 기회를 놓치지 마세요.](https://www.wanted.co.kr/wd/275346?client_id=KK03NuM8GrpMbYP7vrf8FxsI)\n\n[![](https://static.wanted.co.kr/images/company/2400/atafv8ztzucoecwc__400_400.jpg)](https://www.wanted.co.kr/wd/259152?client_id=KK03NuM8GrpMbYP7vrf8FxsI)\n\n[씨제이이엔엠(CJ ENM)](https://www.wanted.co.kr/wd/259152?client_id=KK03NuM8GrpMbYP7vrf8FxsI)\n\n[\\[Mnet Plus\\] 백엔드 개발](https://www.wanted.co.kr/wd/259152?client_id=KK03NuM8GrpMbYP7vrf8FxsI)\n\n[Mnet Plus는 글로벌 KPOP 플랫폼 개발을 통한 K-Culture 소비자와의 연결을 목표로 합니다. Java 또는 Kotlin 경험이 있는 백엔드 개발자를 찾으며, 다양한 서비스 개발로 글로벌 비즈니스 기회를 창출하는 것이 특징입니다.](https://www.wanted.co.kr/wd/259152?client_id=KK03NuM8GrpMbYP7vrf8FxsI)\n\n[![Powered by GraphCDN, the GraphQL CDN](https://graphcdn.io/badge.svg)](https://graphcdn.io/?ref=powered-by)",
        "file_path": "/Users/joonpark/Documents/Obsidian/Obsidian/Clippings/강제로 갈아탄 Obsidian - Dataview로 가계부 정리하기.md",
        "summary": "노션 유료화로 인해 Obsidian으로 갈아탄 저자는 Dataview 플러그인을 활용하여 기존 노션 가계부를 Obsidian에서 재구현했습니다.  페이지 단위로 가계부 항목을 생성하고, Dataview의 JavaScript 문법을 사용하여 표 형태로 데이터를 시각화했습니다.  여기에 더해,  CSS를 활용하여 테이블 디자인을 개선하여 보기 좋고 사용하기 편리한 가계부 시스템을 완성했습니다.\n"
    },
    {
        "title": "뇌 시각피질 선별 처리, AI 이미지 인식 능력↑",
        "url": "file:///Users/joonpark/Documents/Obsidian/Obsidian/Clippings/뇌 시각피질 선별 처리, AI 이미지 인식 능력↑.md",
        "source": "obsidian",
        "body": "---\ntitle: \"뇌 시각피질 선별 처리, AI 이미지 인식 능력↑\"\nsource: \"https://v.daum.net/v/20250422132004124\"\nauthor:\n  - \"[[다음 - 아이뉴스24]]\"\npublished:\ncreated: 2025-04-25T00:00:00\ndescription: \"[아이뉴스24 정종오 기자] 인간의 뇌를 닮은 더 영리한 인공지능 기술이 등장했다. 기초과학연구원(IBS, 원장 노도영) 인지 및 사회성 연구단 이창준 단장 연구팀은 연세대 응용통계학과 송경우 교수 연구팀과 함께 뇌의 시각피질이 시각 정보를 선별해 처리하는 방식을 응용해 인공지능(AI)의 이미지 인식 능력을 높이는 새로운 기술을 개발했다. 인간의 시각 시스\"\ntags:\n  - \"clippings\"\ndate modified: 2025-04-25T21:58:15\n---\n## IT/과학\n\n### 뇌 시각피질 선별 처리, AI 이미지 인식 능력↑\n\n정종오 2025\\. 4. 22. 13:20\n\n인간의 뇌를 닮은 더 영리한 인공지능 기술이 등장했다.\n\n기초과학연구원(IBS, 원장 노도영) 인지 및 사회성 연구단 이창준 단장 연구팀은 연세대 응용통계학과 송경우 교수 연구팀과 함께 뇌의 시각피질이 시각 정보를 선별해 처리하는 방식을 응용해 인공지능(AI)의 이미지 인식 능력을 높이는 새로운 기술을 개발했다.\n\n연구팀은 인간 뇌의 시각 피질이 시각 정보를 선택적으로 처리하는 방식에 주목했다.\n\n[닫기](https://v.daum.net/v/#none)\n\n[닫기](https://v.daum.net/v/#none)\n\n[닫기](https://v.daum.net/v/#none)\n\n이 글자크기로 변경됩니다.\n\n(예시) 가장 빠른 뉴스가 있고 다양한 정보, 쌍방향 소통이 숨쉬는 다음뉴스를 만나보세요. 다음뉴스는 국내외 주요이슈와 실시간 속보, 문화생활 및 다양한 분야의 뉴스를 입체적으로 전달하고 있습니다.\n\n[닫기](https://v.daum.net/v/#none)\n\n**IBS 연구팀, AI 이미지 인식 기술 개발**\n\n\\[아이뉴스24 정종오 기자\\] 인간의 뇌를 닮은 더 영리한 인공지능 기술이 등장했다.\n\n기초과학연구원(IBS, 원장 노도영) 인지 및 사회성 연구단 이창준 단장 연구팀은 연세대 응용통계학과 송경우 교수 연구팀과 함께 뇌의 시각피질이 시각 정보를 선별해 처리하는 방식을 응용해 인공지능(AI)의 이미지 인식 능력을 높이는 새로운 기술을 개발했다.\n\n인간의 시각 시스템은 뛰어난 인식 능력을 갖고 있다. 한눈에 사물을 인식하고, 복잡한 환경에서도 중요한 정보를 빠르게 선별할 수 있다. 기존 AI 모델은 여전히 한계를 보인다.\n\n![실제 뇌의 시각 피질에서는 뉴런들이 중심을 기준으로 넓고 부드럽게 연결돼 있다. 이 연결 강도는 거리마다 점진적으로 달라지는 특성을 보인다(a, b). 반면, 기존의 합성곱 신경망(CNN)에서는 뉴런이 정해진 사각형 범위(예: 3×3, 5×5 등)만을 고정적으로 바라보며 정보를 처리한다(c, d). [사진=IBS]](https://img2.daumcdn.net/thumb/R658x0.q70/?fname=https://t1.daumcdn.net/news/202504/22/inews24/20250422132005791xoht.jpg)\n\n실제 뇌의 시각 피질에서는 뉴런들이 중심을 기준으로 넓고 부드럽게 연결돼 있다. 이 연결 강도는 거리마다 점진적으로 달라지는 특성을 보인다(a, b). 반면, 기존의 합성곱 신경망(CNN)에서는 뉴런이 정해진 사각형 범위(예: 3×3, 5×5 등)만을 고정적으로 바라보며 정보를 처리한다(c, d). \\[사진=IBS\\]\n\n전통적 합성곱 신경망(Convolutional Neural Network, CNN)은 비교적 적은 연산으로도 잘 작동하는데 작은 정사각형 필터로 이미지를 쪼개 분석하는 구조라 넓은 맥락을 파악하거나 떨어진 정보 사이의 관계를 이해하는 데 한계가 있다.\n\n연구팀은 인간 뇌의 시각 피질이 시각 정보를 선택적으로 처리하는 방식에 주목했다. 인간의 시각 피질은 모든 정보를 똑같이 처리하지 않고 눈에 띄는 특징이나 중요한 부분에만 집중해 선택적으로 반응한다.\n\n이 과정에서 뉴런들은 넓은 범위를 부드럽게 감지하며 꼭 필요한 정보에만 선택적으로 반응하는 구조를 갖고 있다. 연구팀은 이러한 방식을 적용해 CNN 모델의 성능을 크게 높이는 ‘Lp-컨볼루션’ 기술을 제안했다.\n\nLp-컨볼루션은 AI가 이미지를 분석할 때 사람처럼 핵심 정보를 우선적으로 파악할 수 있도록 설계된 기술이다. 각 이미지에 대해 자동으로 생성되는 ‘마스크(Mask, 가중치 지도 형태의 필터)’는 시각 피질의 뉴런처럼 중요한 부분을 강조하고 덜 중요한 부분은 자연스럽게 배제하는 방식으로 작동한다.\n\n이 마스크는 학습 과정에서 스스로 형태를 조정하며 다양한 환경에서도 일관되게 중요한 특징에 집중할 수 있게 한다.\n\n제1저자인 권재 IBS 박사후연구원(독일 막스플랑크 보안과 정보보호 연구소)은 “사람이 복잡한 장면에서 핵심을 빠르게 파악하듯 Lp-컨볼루션은 뇌의 정보 처리 방식에서 착안해 AI가 연산 자원을 효율적으로 활용하면서도 더 정확한 분석이 가능하도록 돕는다”고 설명했다.\n\n이창준 IBS 단장은 “Lp-컨볼루션은 AI 성능 향상을 넘어서 뇌가 정보를 어떻게 처리하는지를 모방하고 이해하는 데에도 크게 이바지할 수 있다”며 “AI와 뇌과학이 함께 발전할 수 있는 새로운 융합 모델의 좋은 사례가 될 것”이라고 말했다.\n\n이번 연구(논문명: Brain-Inspired Lp-Convolution Benefits Large Kernels and Aligns Better with Visual Cortex)는 AI 학회 ‘The International Conference on Learning Representations(ICLR)’에 채택돼 오는 24일부터 28일까지 싱가포르에서 열리는 ‘ICLR 2025’에서 발표될 예정이다.\n\n/정종오 기자 (ikokid@inews24.com)\n\nCopyright © 아이뉴스24. 무단전재 및 재배포 금지.\n\n**이 기사에 대해 어떻게 생각하시나요?**",
        "file_path": "/Users/joonpark/Documents/Obsidian/Obsidian/Clippings/뇌 시각피질 선별 처리, AI 이미지 인식 능력↑.md",
        "summary": "IBS 연구팀이 인간 뇌 시각피질의 시각 정보 처리 방식을 모방한 새로운 AI 기술을 개발했습니다.  이 기술은 기존 AI의 이미지 인식 한계를 극복하여 더욱 정확하고 효율적인 이미지 분석을 가능하게 합니다.  이는 AI와 뇌과학의 융합 연구를 통한 성과로, 향후 AI 발전에 크게 기여할 것으로 기대됩니다.\n"
    }
]